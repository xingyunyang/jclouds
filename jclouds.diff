diff --git a/apis/s3/src/main/java/org/jclouds/s3/domain/AccessControlList.java b/apis/s3/src/main/java/org/jclouds/s3/domain/AccessControlList.java
index 34a7366605..71f7621056 100644
--- a/apis/s3/src/main/java/org/jclouds/s3/domain/AccessControlList.java
+++ b/apis/s3/src/main/java/org/jclouds/s3/domain/AccessControlList.java
@@ -382,6 +382,14 @@ public class AccessControlList {
       }
    }
 
+   public static class OssPermissionGrantee extends Grantee {
+      public OssPermissionGrantee(String identifier) {	
+         super(identifier);
+      	}
+      public String getPermission() {
+         return getIdentifier();
+      }
+   }
    public static class EmailAddressGrantee extends Grantee {
       public EmailAddressGrantee(String emailAddress) {
          super(emailAddress);
diff --git a/apis/s3/src/main/java/org/jclouds/s3/filters/Aws4SignerBase.java b/apis/s3/src/main/java/org/jclouds/s3/filters/Aws4SignerBase.java
new file mode 100644
index 0000000000..56d4ecde25
--- /dev/null
+++ b/apis/s3/src/main/java/org/jclouds/s3/filters/Aws4SignerBase.java
@@ -0,0 +1,444 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ * Copyright(C) Inspur Corp. 2017,2018
+ * 
+ * COMPONENT NAME: jclouds
+ * FILE NAME: apis/s3/src/main/java/org/jclouds/s3/filters/Aws4SignerBase.java
+ * DESCRIPTION: add this class for signature headers information of aws-s3 in China.
+ * 
+ * Change Log.
+ * 
+ * 29-07-2017 zreal,Inspur File creation.
+ * 
+ */
+package org.jclouds.s3.filters;
+
+import static com.google.common.base.Charsets.UTF_8;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.io.BaseEncoding.base16;
+import static com.google.common.io.ByteStreams.readBytes;
+import static org.jclouds.crypto.Macs.asByteProcessor;
+import static org.jclouds.http.utils.Queries.queryParser;
+import static org.jclouds.util.Strings2.toInputStream;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URI;
+import java.security.InvalidKeyException;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.Locale;
+import java.util.Map;
+import java.util.SortedMap;
+import java.util.TimeZone;
+
+import javax.xml.ws.http.HTTPException;
+
+import com.google.common.base.Joiner;
+import com.google.common.base.Supplier;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSortedMap;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Multimap;
+import com.google.common.escape.Escaper;
+import com.google.common.hash.Hashing;
+import com.google.common.hash.HashingInputStream;
+import com.google.common.io.ByteProcessor;
+import com.google.common.io.ByteSource;
+import com.google.common.io.ByteStreams;
+import com.google.common.net.HttpHeaders;
+import com.google.common.net.PercentEscaper;
+import com.google.inject.ImplementedBy;
+import org.jclouds.crypto.Crypto;
+import org.jclouds.domain.Credentials;
+import org.jclouds.http.HttpException;
+import org.jclouds.http.HttpRequest;
+import org.jclouds.http.internal.SignatureWire;
+import org.jclouds.io.Payload;
+import org.jclouds.providers.ProviderMetadata;
+
+/**
+ * Common methods and properties for all AWS4 signer variants
+ */
+public abstract class Aws4SignerBase {
+   private static final TimeZone GMT = TimeZone.getTimeZone("GMT");
+   protected final DateFormat timestampFormat;
+   protected final DateFormat dateFormat;
+
+   // Do not URL-encode any of the unreserved characters that RFC 3986 defines:
+   // A-Z, a-z, 0-9, hyphen (-), underscore (_), period (.), and tilde (~).
+   private static final Escaper AWS_URL_PARAMETER_ESCAPER = new PercentEscaper("-_.~", false);
+
+   private static final Escaper AWS_PATH_ESCAPER = new PercentEscaper("/-_.~", false);
+
+   // Specifying a default for how to parse the service and region in this way allows
+   // tests or other downstream services to not have to use guice overrides.
+   @ImplementedBy(ServiceAndRegion.AWSServiceAndRegion.class)
+   public interface ServiceAndRegion {
+      String service();
+
+      String region(String host);
+
+      final class AWSServiceAndRegion implements ServiceAndRegion {
+         private final String service;
+
+         AWSServiceAndRegion(ProviderMetadata provider) {
+            this(provider.getEndpoint());
+         }
+
+         AWSServiceAndRegion(String endpoint) {
+            this.service = AwsHostNameUtils.parseServiceName(URI.create(checkNotNull(endpoint, "endpoint")));
+         }
+
+         @Override
+         public String service() {
+            return service;
+         }
+
+         @Override
+         public String region(String host) {
+            return AwsHostNameUtils.parseRegionName(host, service());
+         }
+      }
+   }
+
+   protected final String headerTag;
+   protected final ServiceAndRegion serviceAndRegion;
+   protected final SignatureWire signatureWire;
+   protected final Supplier<Credentials> creds;
+   protected final Supplier<Date> timestampProvider;
+   protected final Crypto crypto;
+
+
+   protected Aws4SignerBase(SignatureWire signatureWire, String headerTag,
+         Supplier<Credentials> creds, Supplier<Date> timestampProvider,
+         ServiceAndRegion serviceAndRegion, Crypto crypto) {
+      this.signatureWire = signatureWire;
+      this.headerTag = headerTag;
+      this.creds = creds;
+      this.timestampProvider = timestampProvider;
+      this.serviceAndRegion = serviceAndRegion;
+      this.crypto = crypto;
+      this.timestampFormat = new SimpleDateFormat("yyyyMMdd'T'HHmmss'Z'");
+      timestampFormat.setTimeZone(GMT);
+      this.dateFormat = new SimpleDateFormat("yyyyMMdd");
+      dateFormat.setTimeZone(GMT);
+   }
+
+   protected String getContentType(HttpRequest request) {
+      Payload payload = request.getPayload();
+
+      // Default Content Type
+      String contentType = request.getFirstHeaderOrNull(HttpHeaders.CONTENT_TYPE);
+      if (payload != null
+            && payload.getContentMetadata() != null
+            && payload.getContentMetadata().getContentType() != null) {
+         contentType = payload.getContentMetadata().getContentType();
+      }
+      return contentType;
+   }
+
+   protected String getContentLength(HttpRequest request) {
+      Payload payload = request.getPayload();
+
+      // Default Content Type
+      String contentLength = request.getFirstHeaderOrNull(HttpHeaders.CONTENT_LENGTH);
+      if (payload != null
+            && payload.getContentMetadata() != null
+            && payload.getContentMetadata().getContentType() != null) {
+         Long length = payload.getContentMetadata().getContentLength();
+         contentLength =
+               length == null ? contentLength : String.valueOf(payload.getContentMetadata().getContentLength());
+      }
+      return contentLength;
+   }
+
+   // append all of 'x-amz-*' headers
+   protected void appendAmzHeaders(HttpRequest request,
+         ImmutableMap.Builder<String, String> signedHeadersBuilder) {
+      for (Map.Entry<String, String> header : request.getHeaders().entries()) {
+         String key = header.getKey();
+         if (key.startsWith("x-" + headerTag + "-")) {
+            signedHeadersBuilder.put(key.toLowerCase(), header.getValue());
+         }
+      }
+   }
+
+   /**
+    * caluclate AWS signature key.
+    * <p>
+    * <code>
+    * DateKey = hmacSHA256(datestamp, "AWS4"+ secretKey)
+    * <br>
+    * DateRegionKey = hmacSHA256(region, DateKey)
+    * <br>
+    * DateRegionServiceKey = hmacSHA256(service, DateRegionKey)
+    * <br>
+    * SigningKey = hmacSHA256("aws4_request", DateRegionServiceKey)
+    * <br>
+    * <p/>
+    * </code>
+    * </p>
+    *
+    * @param secretKey AWS access secret key
+    * @param datestamp date yyyyMMdd
+    * @param region   AWS region
+    * @param service   AWS service
+    * @return SigningKey
+    */
+   protected byte[] signatureKey(String secretKey, String datestamp, String region, String service) {
+      byte[] kSecret = ("AWS4" + secretKey).getBytes(UTF_8);
+      byte[] kDate = hmacSHA256(datestamp, kSecret);
+      byte[] kRegion = hmacSHA256(region, kDate);
+      byte[] kService = hmacSHA256(service, kRegion);
+      byte[] kSigning = hmacSHA256("aws4_request", kService);
+      return kSigning;
+   }
+
+   /**
+    * hmac sha256
+    *
+    * @param toSign string to sign
+    * @param key   hash key
+    */
+   protected byte[] hmacSHA256(String toSign, byte[] key) {
+      try {
+         return readBytes(toInputStream(toSign), hmacSHA256(crypto, key));
+      } catch (IOException e) {
+         throw new HttpException("read sign error", e);
+      } catch (InvalidKeyException e) {
+         throw new HttpException("invalid key", e);
+      }
+   }
+
+   public static ByteProcessor<byte[]> hmacSHA256(Crypto crypto, byte[] signatureKey) throws InvalidKeyException {
+      return asByteProcessor(crypto.hmacSHA256(signatureKey));
+   }
+
+   /**
+    * hash input with sha256
+    *
+    * @param input
+    * @return hash result
+    * @throws HTTPException
+    */
+   public static byte[] hash(InputStream input) throws HTTPException {
+      HashingInputStream his = new HashingInputStream(Hashing.sha256(), input);
+      try {
+         ByteStreams.copy(his, ByteStreams.nullOutputStream());
+         return his.hash().asBytes();
+      } catch (IOException e) {
+         throw new HttpException("Unable to compute hash while signing request: " + e.getMessage(), e);
+      }
+   }
+
+   /**
+    * hash input with sha256
+    *
+    * @param bytes input bytes
+    * @return hash result
+    * @throws HTTPException
+    */
+   public static byte[] hash(byte[] bytes) throws HTTPException {
+      try {
+         return ByteSource.wrap(bytes).hash(Hashing.sha256()).asBytes();
+      } catch (IOException e) {
+         throw new HttpException("Unable to compute hash while signing request: " + e.getMessage(), e);
+      }
+   }
+
+
+   /**
+    * hash string (encoding UTF_8) with sha256
+    *
+    * @param input input stream
+    * @return hash result
+    * @throws HTTPException
+    */
+   public static byte[] hash(String input) throws HTTPException {
+      return hash(new ByteArrayInputStream(input.getBytes(UTF_8)));
+   }
+
+   /**
+    * Examines the specified query string parameters and returns a
+    * canonicalized form.
+    * <p/>
+    * The canonicalized query string is formed by first sorting all the query
+    * string parameters, then URI encoding both the key and value and then
+    * joining them, in order, separating key value pairs with an '&'.
+    *
+    * @param queryString The query string parameters to be canonicalized.
+    * @return A canonicalized form for the specified query string parameters.
+    */
+   protected String getCanonicalizedQueryString(String queryString) {
+      Multimap<String, String> params = queryParser().apply(queryString);
+      SortedMap<String, String> sorted = Maps.newTreeMap();
+      if (params == null) {
+         return "";
+      }
+      Iterator<Map.Entry<String, String>> pairs = params.entries().iterator();
+      while (pairs.hasNext()) {
+         Map.Entry<String, String> pair = pairs.next();
+         String key = pair.getKey();
+         String value = pair.getValue();
+         sorted.put(urlEncode(key), urlEncode(value));
+      }
+
+      return Joiner.on("&").withKeyValueSeparator("=").join(sorted);
+   }
+
+   /**
+    * Encode a string for use in the path of a URL; uses URLEncoder.encode,
+    * (which encodes a string for use in the query portion of a URL), then
+    * applies some postfilters to fix things up per the RFC. Can optionally
+    * handle strings which are meant to encode a path (ie include '/'es
+    * which should NOT be escaped).
+    *
+    * @param value the value to encode
+    * @return the encoded value
+    */
+   public static String urlEncode(final String value) {
+      if (value == null) {
+         return "";
+      }
+      return AWS_URL_PARAMETER_ESCAPER.escape(value);
+   }
+
+   /**
+    * Lowercase base 16 encoding.
+    *
+    * @param bytes bytes
+    * @return base16 lower case hex string.
+    */
+   public static String hex(final byte[] bytes) {
+      return base16().lowerCase().encode(bytes);
+   }
+
+   /**
+    * Create a Canonical Request to sign
+    * <h4>Canonical Request</h4>
+    * <p>
+    * <code>
+    * &lt;HTTPMethod>\n
+    * <br>
+    * &lt;CanonicalURI>\n
+    * <br>
+    * &lt;CanonicalQueryString>\n
+    * <br>
+    * &lt;CanonicalHeaders>\n
+    * <br>
+    * &lt;SignedHeaders>\n
+    * <br>
+    * &lt;HashedPayload>
+    * </code>
+    * </p>
+    * <p><b>HTTPMethod</b> is one of the HTTP methods, for example GET, PUT, HEAD, and DELETE.</p>
+    * <p><b>CanonicalURI</b> is the URI-encoded version of the absolute path component of the URIâ€”everything starting
+    * with the "/" that follows the domain name and up to the end of the string or to the question mark character ('?')
+    * if you have query string parameters.</p>
+    * <p><b>CanonicalQueryString</b> specifies the URI-encoded query string parameters. You URI-encode name and values
+    * individually. You must also sort the parameters in the canonical query string alphabetically by key name.
+    * The sorting occurs after encoding.</p>
+    * <p><b>CanonicalHeaders</b> is a list of request headers with their values. Individual header name and value pairs are
+    * separated by the newline character ("\n"). Header names must be in lowercase. Header value must be trim space.
+    * <br>
+    * The <b>CanonicalHeaders</b> list must include the following:
+    * HTTP host header.
+    * If the Content-Type header is present in the request, it must be added to the CanonicalHeaders list.
+    * Any x-amz-* headers that you plan to include in your request must also be added.</p>
+    * <p><b>SignedHeaders</b> is an alphabetically sorted, semicolon-separated list of lowercase request header names.
+    * The request headers in the list are the same headers that you included in the CanonicalHeaders string.</p>
+    * <p><b>HashedPayload</b> is the hexadecimal value of the SHA256 hash of the request payload. </p>
+    * <p>If there is no payload in the request, you compute a hash of the empty string as follows:
+    * <code>Hex(SHA256Hash(""))</code> The hash returns the following value:
+    * e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855  </p>
+    *
+    * @param method           http request method
+    * @param endpoint         http request endpoing
+    * @param signedHeaders    signed headers
+    * @param timestamp        ISO8601 timestamp
+    * @param credentialScope  credential scope
+    * @return string to sign
+    */
+   protected String createStringToSign(String method, URI endpoint, Map<String, String> signedHeaders,
+         String timestamp, String credentialScope, String hashedPayload) {
+
+      // lower case header keys
+      Map<String, String> lowerCaseHeaders = lowerCaseNaturalOrderKeys(signedHeaders);
+
+      StringBuilder canonicalRequest = new StringBuilder();
+
+      // HTTPRequestMethod + '\n' +
+      canonicalRequest.append(method).append("\n");
+
+      // CanonicalURI + '\n' +
+      canonicalRequest.append(AWS_PATH_ESCAPER.escape(endpoint.getPath())).append("\n");
+
+      // CanonicalQueryString + '\n' +
+      if (endpoint.getQuery() != null) {
+         canonicalRequest.append(getCanonicalizedQueryString(endpoint.getQuery()));
+      }
+      canonicalRequest.append("\n");
+
+      // CanonicalHeaders + '\n' +
+      for (Map.Entry<String, String> entry : lowerCaseHeaders.entrySet()) {
+         canonicalRequest.append(entry.getKey()).append(':').append(entry.getValue()).append('\n');
+      }
+      canonicalRequest.append("\n");
+
+      // SignedHeaders + '\n' +
+      canonicalRequest.append(Joiner.on(';').join(lowerCaseHeaders.keySet())).append('\n');
+
+      // HexEncode(Hash(Payload))
+      canonicalRequest.append(hashedPayload);
+
+      signatureWire.getWireLog().debug("<< " + canonicalRequest);
+      
+      // Create a String to Sign
+      StringBuilder toSign = new StringBuilder();
+      // Algorithm + '\n' +
+      toSign.append("AWS4-HMAC-SHA256").append('\n');
+      // RequestDate + '\n' +
+      toSign.append(timestamp).append('\n');
+      // CredentialScope + '\n' +
+//      toSign.append(credentialScope);
+      toSign.append(credentialScope).append('\n');
+      // HexEncode(Hash(CanonicalRequest))
+      toSign.append(hex(hash(canonicalRequest.toString())));
+
+      return toSign.toString();
+   }
+
+   /**
+    * change the keys but keep the values in-tact.
+    *
+    * @param in input map to transform
+    * @return immutableSortedMap with the new lowercase keys.
+    */
+   protected static Map<String, String> lowerCaseNaturalOrderKeys(Map<String, String> in) {
+      checkNotNull(in, "input map");
+      ImmutableSortedMap.Builder<String, String> returnVal = ImmutableSortedMap.<String, String>naturalOrder();
+      for (Map.Entry<String, String> entry : in.entrySet())
+         returnVal.put(entry.getKey().toLowerCase(Locale.US), entry.getValue());
+      return returnVal.build();
+   }
+
+}
diff --git a/apis/s3/src/main/java/org/jclouds/s3/filters/Aws4SignerForAuthorizationHeader.java b/apis/s3/src/main/java/org/jclouds/s3/filters/Aws4SignerForAuthorizationHeader.java
new file mode 100644
index 0000000000..e31b79c716
--- /dev/null
+++ b/apis/s3/src/main/java/org/jclouds/s3/filters/Aws4SignerForAuthorizationHeader.java
@@ -0,0 +1,229 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ * Copyright(C) Inspur Corp. 2017,2018
+ * 
+ * COMPONENT NAME: jclouds
+ * FILE NAME: apis/s3/src/main/java/org/jclouds/s3/filters/Aws4SignerForAuthorizationHeader.java
+ * DESCRIPTION: add this class for signature headers information of aws-s3 in China.
+ * 
+ * Change Log.
+ * 
+ * 29-07-2017 zreal,Inspur File creation.
+ * 
+ */
+package org.jclouds.s3.filters;
+
+import com.google.common.base.Joiner;
+import com.google.common.base.Strings;
+import com.google.common.base.Supplier;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSortedMap;
+import com.google.common.hash.HashCode;
+import com.google.common.io.BaseEncoding;
+import com.google.common.net.HttpHeaders;
+
+import org.jclouds.aws.domain.SessionCredentials;
+import org.jclouds.crypto.Crypto;
+import org.jclouds.domain.Credentials;
+import org.jclouds.http.HttpException;
+import org.jclouds.http.HttpRequest;
+import org.jclouds.http.internal.SignatureWire;
+import org.jclouds.io.Payload;
+import org.jclouds.util.Closeables2;
+
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+import java.util.Date;
+
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.io.BaseEncoding.base16;
+import static com.google.common.net.HttpHeaders.AUTHORIZATION;
+import static com.google.common.net.HttpHeaders.CONTENT_MD5;
+import static com.google.common.net.HttpHeaders.DATE;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_ALGORITHM_HMAC_SHA256;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_CONTENT_SHA256_HEADER;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_DATE_HEADER;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_SECURITY_TOKEN_HEADER;
+
+/**
+ * AWS4 signer sign requests to Amazon S3 using an 'Authorization' header.
+ */
+public class Aws4SignerForAuthorizationHeader extends Aws4SignerBase {
+	
+   public Aws4SignerForAuthorizationHeader(SignatureWire signatureWire,
+         boolean isVhostStyle,
+         String headerTag,
+         Supplier<Credentials> creds, Supplier<Date> timestampProvider,
+         ServiceAndRegion serviceAndRegion, Crypto crypto) {
+      super(signatureWire, headerTag, creds, timestampProvider, serviceAndRegion, crypto);
+   }
+
+   protected HttpRequest sign(HttpRequest request) throws HttpException {
+      checkNotNull(request, "request is not ready to sign");
+      checkNotNull(request.getEndpoint(), "request is not ready to sign, request.endpoint not present.");
+
+      Payload payload = request.getPayload();
+      // get host from request endpoint.
+      String host = request.getEndpoint().getHost();
+
+      Date date = timestampProvider.get();
+      String timestamp = timestampFormat.format(date);
+      String datestamp = dateFormat.format(date);
+
+      String service = serviceAndRegion.service();
+      String region = serviceAndRegion.region(host);
+      String credentialScope = Joiner.on('/').join(datestamp, region, service, "aws4_request");
+
+      HttpRequest.Builder<?> requestBuilder = request.toBuilder() //
+            .removeHeader(AUTHORIZATION) // remove Authorization
+            .removeHeader(DATE); // remove date
+      
+      ImmutableMap.Builder<String, String> signedHeadersBuilder = ImmutableSortedMap.<String, String>naturalOrder();
+
+      // Content Type
+      // content-type is not a required signing param. However, examples use this, so we include it to ease testing.
+      String contentType = getContentType(request);
+      if (!Strings.isNullOrEmpty(contentType)) {
+         requestBuilder.replaceHeader(HttpHeaders.CONTENT_TYPE, contentType);
+         signedHeadersBuilder.put(HttpHeaders.CONTENT_TYPE.toLowerCase(), contentType);
+      }
+
+      // Content-Length for PUT or POST request http method
+      String contentLength = getContentLength(request);
+      if (!Strings.isNullOrEmpty(contentLength)) {
+         requestBuilder.replaceHeader(HttpHeaders.CONTENT_LENGTH, contentLength);
+         signedHeadersBuilder.put(HttpHeaders.CONTENT_LENGTH.toLowerCase(), contentLength);
+      }
+
+      // Content MD5
+      String contentMD5 = request.getFirstHeaderOrNull(CONTENT_MD5);
+      if (payload != null) {
+         HashCode md5 = payload.getContentMetadata().getContentMD5AsHashCode();
+         if (md5 != null) {
+            contentMD5 = BaseEncoding.base64().encode(md5.asBytes());
+         }
+      }
+      if (contentMD5 != null) {
+         requestBuilder.replaceHeader(CONTENT_MD5, contentMD5);
+         signedHeadersBuilder.put(CONTENT_MD5.toLowerCase(), contentMD5);
+      }
+
+      // host
+      requestBuilder.replaceHeader(HttpHeaders.HOST, host);
+      signedHeadersBuilder.put(HttpHeaders.HOST.toLowerCase(), host);
+
+      // user-agent
+      if (request.getHeaders().containsKey(HttpHeaders.USER_AGENT)) {
+         signedHeadersBuilder.put(HttpHeaders.USER_AGENT.toLowerCase(),
+               request.getFirstHeaderOrNull(HttpHeaders.USER_AGENT));
+      }
+
+      // all x-amz-* headers
+      appendAmzHeaders(request, signedHeadersBuilder);
+
+      // x-amz-security-token
+      Credentials credentials = creds.get();
+      if (credentials instanceof SessionCredentials) {
+         String token = SessionCredentials.class.cast(credentials).getSessionToken();
+         requestBuilder.replaceHeader(AMZ_SECURITY_TOKEN_HEADER, token);
+         signedHeadersBuilder.put(AMZ_SECURITY_TOKEN_HEADER.toLowerCase(), token);
+      }
+
+      // x-amz-content-sha256
+      String contentSha256 = getPayloadHash(request);
+      requestBuilder.replaceHeader(AMZ_CONTENT_SHA256_HEADER, contentSha256);
+      signedHeadersBuilder.put(AMZ_CONTENT_SHA256_HEADER.toLowerCase(), contentSha256);
+
+      // put x-amz-date
+      requestBuilder.replaceHeader(AMZ_DATE_HEADER, timestamp);
+      signedHeadersBuilder.put(AMZ_DATE_HEADER.toLowerCase(), timestamp);
+      ImmutableMap<String, String> signedHeaders = signedHeadersBuilder.build();
+
+      String stringToSign = createStringToSign(request.getMethod(), request.getEndpoint(), signedHeaders, timestamp,
+            credentialScope, contentSha256);
+      signatureWire.getWireLog().debug("<< " + stringToSign);
+
+      byte[] signatureKey = signatureKey(credentials.credential, datestamp, region, service);
+      String signature = base16().lowerCase().encode(hmacSHA256(stringToSign, signatureKey));
+
+      StringBuilder authorization = new StringBuilder(AMZ_ALGORITHM_HMAC_SHA256).append(" ");
+      authorization.append("Credential=").append(Joiner.on("/").join(credentials.identity, credentialScope))
+            .append(", ");
+      authorization.append("SignedHeaders=").append(Joiner.on(";").join(signedHeaders.keySet()))
+            .append(", ");
+      authorization.append("Signature=").append(signature);
+    
+      return requestBuilder.replaceHeader(HttpHeaders.AUTHORIZATION, authorization.toString()).build();
+   }
+
+   protected String getPayloadHash(HttpRequest request) {
+      Payload payload = request.getPayload();
+      if (payload == null) {
+         // when payload is null.
+         return getEmptyPayloadContentHash();
+      }
+      return calculatePayloadContentHash(payload);
+   }
+
+   /**
+    * The hash returns the following value: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
+    */
+   protected String getEmptyPayloadContentHash() {
+      return base16().lowerCase().encode(hash(new ByteArrayInputStream(new byte[0])));
+   }
+
+   /**
+    * in this time, payload ContentMetadata provided content hash md5, but aws required sha256.
+    */
+   protected String calculatePayloadContentHash(Payload payload) {
+      // use payload stream calculate content sha256
+      InputStream payloadStream;
+      try {
+         payloadStream = payload.openStream();
+      } catch (IOException e) {
+         throw new HttpException("unable to open payload stream to calculate AWS4 signature.");
+      }
+      try {
+         return base16().lowerCase().encode(hash(payloadStream));
+      } finally {
+         closeOrResetPayloadStream(payloadStream, payload.isRepeatable());
+      }
+   }
+
+   // some times, when use Multipart Payload and a part can not be repeatable, will happen some error...
+   void closeOrResetPayloadStream(InputStream payloadStream, boolean repeatable) {
+      // if payload stream can repeatable.
+      if (repeatable) {
+         Closeables2.closeQuietly(payloadStream);
+      } else {
+         try {
+            // reset unrepeatable payload stream
+            payloadStream.reset();
+         } catch (IOException e) {
+            // reset payload stream
+            throw new HttpException(
+                  "unable to reset unrepeatable payload stream after calculating AWS4 signature.");
+         }
+      }
+   }
+   
+}
diff --git a/apis/s3/src/main/java/org/jclouds/s3/filters/Aws4SignerForChunkedUpload.java b/apis/s3/src/main/java/org/jclouds/s3/filters/Aws4SignerForChunkedUpload.java
new file mode 100644
index 0000000000..5708c45247
--- /dev/null
+++ b/apis/s3/src/main/java/org/jclouds/s3/filters/Aws4SignerForChunkedUpload.java
@@ -0,0 +1,279 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ * Copyright(C) Inspur Corp. 2017,2018
+ * 
+ * COMPONENT NAME: jclouds
+ * FILE NAME: apis/s3/src/main/java/org/jclouds/s3/filters/Aws4SignerForChunkedUpload.java
+ * DESCRIPTION: add this class for signature headers information of aws-s3 in China.
+ * 
+ * Change Log.
+ * 
+ * 29-07-2017 zreal,Inspur File creation.
+ * 
+ */
+package org.jclouds.s3.filters;
+
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_ALGORITHM_HMAC_SHA256;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_CONTENT_SHA256_HEADER;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_DATE_HEADER;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_DECODED_CONTENT_LENGTH_HEADER;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_SECURITY_TOKEN_HEADER;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.CHUNK_SIGNATURE_HEADER;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.CLRF;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.CONTENT_ENCODING_HEADER_AWS_CHUNKED;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.SIGNATURE_LENGTH;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.STREAMING_BODY_SHA256;
+import static org.jclouds.util.Strings2.toInputStream;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.io.ByteStreams.readBytes;
+import static com.google.common.net.HttpHeaders.AUTHORIZATION;
+import static com.google.common.net.HttpHeaders.CONTENT_LENGTH;
+import static com.google.common.net.HttpHeaders.CONTENT_MD5;
+import static com.google.common.net.HttpHeaders.DATE;
+
+import java.io.IOException;
+import java.security.InvalidKeyException;
+import java.util.Date;
+
+
+import org.jclouds.aws.domain.SessionCredentials;
+import org.jclouds.crypto.Crypto;
+import org.jclouds.domain.Credentials;
+import org.jclouds.http.HttpException;
+import org.jclouds.http.HttpRequest;
+import org.jclouds.http.internal.SignatureWire;
+import org.jclouds.io.Payload;
+
+import com.google.common.base.Joiner;
+import com.google.common.base.Strings;
+import com.google.common.base.Supplier;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSortedMap;
+import com.google.common.hash.HashCode;
+import com.google.common.io.BaseEncoding;
+import com.google.common.io.ByteProcessor;
+import com.google.common.net.HttpHeaders;
+
+/**
+ * AWS4 signer sign 'chunked' uploads.
+ */
+public class Aws4SignerForChunkedUpload extends Aws4SignerBase {
+
+   private final int userDataBlockSize;
+
+   public Aws4SignerForChunkedUpload(SignatureWire signatureWire,
+         String headerTag,
+         int userDataBlockSize,
+         Supplier<Credentials> creds, Supplier<Date> timestampProvider,
+         ServiceAndRegion serviceAndRegion, Crypto crypto) {
+      super(signatureWire, headerTag, creds, timestampProvider, serviceAndRegion, crypto);
+      this.userDataBlockSize = userDataBlockSize;
+   }
+
+   protected HttpRequest sign(HttpRequest request) throws HttpException {
+      checkNotNull(request, "request is not ready to sign");
+      checkNotNull(request.getEndpoint(), "request is not ready to sign, request.endpoint not present.");
+
+      Payload payload = request.getPayload();
+      // chunked upload required content-length.
+      Long contentLength = payload.getContentMetadata().getContentLength();
+
+      // check contentLength not null
+      checkNotNull(contentLength, "request is not ready to sign, payload contentLength not present.");
+
+      // get host from request endpoint.
+      String host = request.getEndpoint().getHost();
+
+      Date date = timestampProvider.get();
+      String timestamp = timestampFormat.format(date);
+      String datestamp = dateFormat.format(date);
+
+      String service = serviceAndRegion.service();
+      String region = serviceAndRegion.region(host);
+      String credentialScope = Joiner.on('/').join(datestamp, region, service, "aws4_request");
+
+      HttpRequest.Builder<?> requestBuilder = request.toBuilder() //
+            .removeHeader(AUTHORIZATION) // remove Authorization
+            .removeHeader(DATE) // remove Date
+            .removeHeader(CONTENT_LENGTH); // remove Content-Length
+
+      ImmutableMap.Builder<String, String> signedHeadersBuilder = ImmutableSortedMap.<String, String>naturalOrder();
+
+      // content-encoding
+      String contentEncoding = CONTENT_ENCODING_HEADER_AWS_CHUNKED;
+      String originalContentEncoding = payload.getContentMetadata().getContentEncoding();
+      if (originalContentEncoding != null) {
+         contentEncoding += "," + originalContentEncoding;
+      }
+      requestBuilder.replaceHeader(HttpHeaders.CONTENT_ENCODING, contentEncoding);
+      signedHeadersBuilder.put(HttpHeaders.CONTENT_ENCODING.toLowerCase(), contentEncoding);
+
+
+      // x-amz-decoded-content-length
+      requestBuilder.replaceHeader(AMZ_DECODED_CONTENT_LENGTH_HEADER, contentLength.toString());
+      signedHeadersBuilder.put(AMZ_DECODED_CONTENT_LENGTH_HEADER.toLowerCase(), contentLength.toString());
+
+      // how big is the overall request stream going to be once we add the signature
+      // 'headers' to each chunk?
+      long totalLength = calculateChunkedContentLength(contentLength, userDataBlockSize);
+      requestBuilder.replaceHeader(CONTENT_LENGTH, Long.toString(totalLength));
+      signedHeadersBuilder.put(CONTENT_LENGTH.toLowerCase(), Long.toString(totalLength));
+
+      // Content MD5
+      String contentMD5 = request.getFirstHeaderOrNull(CONTENT_MD5);
+      if (payload != null) {
+         HashCode md5 = payload.getContentMetadata().getContentMD5AsHashCode();
+         if (md5 != null) {
+            contentMD5 = BaseEncoding.base64().encode(md5.asBytes());
+         }
+      }
+      if (contentMD5 != null) {
+         requestBuilder.replaceHeader(CONTENT_MD5, contentMD5);
+         signedHeadersBuilder.put(CONTENT_MD5.toLowerCase(), contentMD5);
+      }
+
+      // Content Type
+      // content-type is not a required signing param. However, examples use this, so we include it to ease testing.
+      String contentType = getContentType(request);
+      if (!Strings.isNullOrEmpty(contentType)) {
+         requestBuilder.replaceHeader(HttpHeaders.CONTENT_TYPE, contentType);
+         signedHeadersBuilder.put(HttpHeaders.CONTENT_TYPE.toLowerCase(), contentType);
+      } else {
+         requestBuilder.removeHeader(HttpHeaders.CONTENT_TYPE);
+      }
+
+      // host
+      requestBuilder.replaceHeader(HttpHeaders.HOST, host);
+      signedHeadersBuilder.put(HttpHeaders.HOST.toLowerCase(), host);
+
+      // user-agent, not a required signing param
+      if (request.getHeaders().containsKey(HttpHeaders.USER_AGENT)) {
+         signedHeadersBuilder.put(HttpHeaders.USER_AGENT.toLowerCase(),
+               request.getFirstHeaderOrNull(HttpHeaders.USER_AGENT));
+      }
+
+      // all x-amz-* headers
+      appendAmzHeaders(request, signedHeadersBuilder);
+
+      // x-amz-security-token
+      Credentials credentials = creds.get();
+      if (credentials instanceof SessionCredentials) {
+         String token = SessionCredentials.class.cast(credentials).getSessionToken();
+         requestBuilder.replaceHeader(AMZ_SECURITY_TOKEN_HEADER, token);
+         signedHeadersBuilder.put(AMZ_SECURITY_TOKEN_HEADER.toLowerCase(), token);
+      }
+
+      // x-amz-content-sha256
+      String contentSha256 = getPayloadHash();
+      requestBuilder.replaceHeader(AMZ_CONTENT_SHA256_HEADER, contentSha256);
+      signedHeadersBuilder.put(AMZ_CONTENT_SHA256_HEADER.toLowerCase(), contentSha256);
+
+      // put x-amz-date
+      requestBuilder.replaceHeader(AMZ_DATE_HEADER, timestamp);
+      signedHeadersBuilder.put(AMZ_DATE_HEADER.toLowerCase(), timestamp);
+
+      ImmutableMap<String, String> signedHeaders = signedHeadersBuilder.build();
+
+      String stringToSign = createStringToSign(request.getMethod(), request.getEndpoint(), signedHeaders, timestamp,
+            credentialScope, contentSha256);
+      signatureWire.getWireLog().debug("<< " + stringToSign);
+
+      byte[] signatureKey = signatureKey(credentials.credential, datestamp, region, service);
+
+      // init hmacSHA256 processor for seed signature and chunked block signature
+      ByteProcessor<byte[]> hmacSHA256;
+      try {
+         hmacSHA256 = hmacSHA256(crypto, signatureKey);
+      } catch (InvalidKeyException e) {
+         throw new ChunkedUploadException("invalid key", e);
+      }
+
+      // Calculating the Seed Signature
+      String signature;
+      try {
+         signature = hex(readBytes(toInputStream(stringToSign), hmacSHA256));
+      } catch (IOException e) {
+         throw new ChunkedUploadException("hmac sha256 seed signature error", e);
+      }
+
+      StringBuilder authorization = new StringBuilder(AMZ_ALGORITHM_HMAC_SHA256).append(" ");
+      authorization.append("Credential=").append(Joiner.on("/").join(credentials.identity, credentialScope))
+            .append(", ");
+      authorization.append("SignedHeaders=").append(Joiner.on(";").join(signedHeaders.keySet()))
+            .append(", ");
+      authorization.append("Signature=").append(signature);
+
+      // replace request payload with chunked upload payload
+      ChunkedUploadPayload chunkedPayload = new ChunkedUploadPayload(payload, userDataBlockSize, timestamp,
+            credentialScope, hmacSHA256, signature);
+      chunkedPayload.getContentMetadata().setContentEncoding(null);
+
+      return requestBuilder
+            .replaceHeader(HttpHeaders.AUTHORIZATION, authorization.toString())
+            .payload(chunkedPayload)
+            .build();
+
+   }
+
+   // for seed signature, value: STREAMING-AWS4-HMAC-SHA256-PAYLOAD
+   protected String getPayloadHash() {
+      return STREAMING_BODY_SHA256;
+   }
+
+   /**
+    * Calculates the expanded payload size of our data when it is chunked
+    *
+    * @param originalLength The true size of the data payload to be uploaded
+    * @param chunkSize     The size of each chunk we intend to send; each chunk will be
+    *                  prefixed with signed header data, expanding the overall size
+    *                  by a determinable amount
+    * @return The overall payload size to use as content-length on a chunked
+    * upload
+    */
+   public static long calculateChunkedContentLength(long originalLength, long chunkSize) {
+      checkArgument(originalLength > 0, "Nonnegative content length expected.");
+
+      long maxSizeChunks = originalLength / chunkSize;
+      long remainingBytes = originalLength % chunkSize;
+      return maxSizeChunks * calculateChunkHeaderLength(chunkSize)
+            + (remainingBytes > 0 ? calculateChunkHeaderLength(remainingBytes) : 0)
+            + calculateChunkHeaderLength(0);
+   }
+
+   /**
+    * Returns the size of a chunk header, which only varies depending on the
+    * selected chunk size
+    *
+    * @param chunkDataSize The intended size of each chunk; this is placed into the chunk
+    *                 header
+    * @return The overall size of the header that will prefix the user data in
+    * each chunk
+    */
+   private static long calculateChunkHeaderLength(long chunkDataSize) {
+      return Long.toHexString(chunkDataSize).length()
+            + CHUNK_SIGNATURE_HEADER.length()
+            + SIGNATURE_LENGTH
+            + CLRF.length()
+            + chunkDataSize
+            + CLRF.length();
+   }
+
+
+}
diff --git a/apis/s3/src/main/java/org/jclouds/s3/filters/Aws4SignerForQueryString.java b/apis/s3/src/main/java/org/jclouds/s3/filters/Aws4SignerForQueryString.java
new file mode 100644
index 0000000000..6a2088ed18
--- /dev/null
+++ b/apis/s3/src/main/java/org/jclouds/s3/filters/Aws4SignerForQueryString.java
@@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ * Copyright(C) Inspur Corp. 2017,2018
+ * 
+ * COMPONENT NAME: jclouds
+ * FILE NAME: apis/s3/src/main/java/org/jclouds/s3/filters/Aws4SignerForQueryString.java
+ * DESCRIPTION: add this class for signature headers information of aws-s3 in China.
+ * 
+ * Change Log.
+ * 
+ * 29-07-2017 zreal,Inspur File creation.
+ * 
+ */
+package org.jclouds.s3.filters;
+
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_ALGORITHM_PARAM;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_CONTENT_SHA256_HEADER;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_CREDENTIAL_PARAM;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_DATE_HEADER;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_DATE_PARAM;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_EXPIRES_PARAM;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_SECURITY_TOKEN_PARAM;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_SIGNATURE_PARAM;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AMZ_SIGNEDHEADERS_PARAM;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.AUTHORIZATION_HEADER;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.UNSIGNED_PAYLOAD;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.io.BaseEncoding.base16;
+
+import java.util.Date;
+
+
+import org.jclouds.aws.domain.SessionCredentials;
+import org.jclouds.crypto.Crypto;
+import org.jclouds.domain.Credentials;
+import org.jclouds.http.HttpException;
+import org.jclouds.http.HttpRequest;
+import org.jclouds.http.Uris;
+import org.jclouds.http.internal.SignatureWire;
+
+import com.google.common.base.Joiner;
+import com.google.common.base.Supplier;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSortedMap;
+
+/**
+ * AWS4 signer sign requests to Amazon S3 using query string parameters.
+ */
+public class Aws4SignerForQueryString extends Aws4SignerBase {
+
+	public Aws4SignerForQueryString(SignatureWire signatureWire,
+         boolean isVhostStyle,
+         String headerTag,
+         Supplier<Credentials> creds, Supplier<Date> timestampProvider,
+         ServiceAndRegion serviceAndRegion, Crypto crypto) {
+      super(signatureWire, headerTag, creds, timestampProvider, serviceAndRegion, crypto);
+   }
+
+
+   protected HttpRequest sign(HttpRequest request, long timeInSeconds) throws HttpException {
+      checkNotNull(request, "request is not ready to sign");
+      checkNotNull(request.getEndpoint(), "request is not ready to sign, request.endpoint not present.");
+
+      // get host from request endpoint.
+      String host = request.getEndpoint().getHost();
+
+      Date date = timestampProvider.get();
+      String timestamp = timestampFormat.format(date);
+      String datestamp = dateFormat.format(date);
+
+      String service = serviceAndRegion.service();
+      String region = serviceAndRegion.region(host);
+      String credentialScope = Joiner.on('/').join(datestamp, region, service, "aws4_request");
+
+      // different with signature with Authorization header
+      HttpRequest.Builder<?> requestBuilder = request.toBuilder() //
+            // sign for temporary access use query string parameter:
+            // X-Amz-Algorithm, X-Amz-Credential, X-Amz-Date, X-Amz-Expires, X-Amz-SignedHeaders, X-Amz-Signature
+            // remove Authorization, x-amz-content-sha256, X-Amz-Date headers
+            .removeHeader(AUTHORIZATION_HEADER)
+            .removeHeader(AMZ_CONTENT_SHA256_HEADER)
+            .removeHeader(AMZ_DATE_HEADER);
+
+      ImmutableMap.Builder<String, String> signedHeadersBuilder = ImmutableSortedMap.<String, String>naturalOrder(); //
+      Uris.UriBuilder endpointBuilder = Uris.uriBuilder(request.getEndpoint());
+
+
+      // Canonical Headers
+      // must include the HTTP host header.
+      // If you plan to include any of the x-amz-* headers, these headers must also be added for signature calculation.
+      // You can optionally add all other headers that you plan to include in your request.
+      // For added security, you should sign as many headers as possible.
+
+      // HOST
+      signedHeadersBuilder.put("host", host);
+      ImmutableMap<String, String> signedHeaders = signedHeadersBuilder.build();
+
+      Credentials credentials = creds.get();
+
+      if (credentials instanceof SessionCredentials) {
+         String token = SessionCredentials.class.cast(credentials).getSessionToken();
+         // different with signature with Authorization header
+         endpointBuilder.replaceQuery(AMZ_SECURITY_TOKEN_PARAM, token);
+      }
+
+      // X-Amz-Algorithm=HMAC-SHA256
+      endpointBuilder.replaceQuery(AMZ_ALGORITHM_PARAM, AwsSignatureV4Constants.AMZ_ALGORITHM_HMAC_SHA256);
+
+      // X-Amz-Credential=<your-access-key-id>/<date>/<AWS-region>/<AWS-service>/aws4_request.
+      String credential = Joiner.on("/").join(credentials.identity, credentialScope);
+      endpointBuilder.replaceQuery(AMZ_CREDENTIAL_PARAM, credential);
+
+      // X-Amz-Date=ISO 8601 format, for example, 20130721T201207Z
+      endpointBuilder.replaceQuery(AMZ_DATE_PARAM, timestamp);
+
+      // X-Amz-Expires=time in seconds
+      endpointBuilder.replaceQuery(AMZ_EXPIRES_PARAM, String.valueOf(timeInSeconds));
+
+      // X-Amz-SignedHeaders=HTTP host header is required.
+      endpointBuilder.replaceQuery(AMZ_SIGNEDHEADERS_PARAM, Joiner.on(';').join(signedHeaders.keySet()));
+
+      String stringToSign = createStringToSign(request.getMethod(), endpointBuilder.build(), signedHeaders, timestamp, credentialScope,
+            getPayloadHash());
+
+      signatureWire.getWireLog().debug("<< " + stringToSign);
+
+
+      byte[] signatureKey = signatureKey(credentials.credential, datestamp, region, service);
+      String signature = base16().lowerCase().encode(hmacSHA256(stringToSign, signatureKey));
+
+      // X-Amz-Signature=Signature
+      endpointBuilder.replaceQuery(AMZ_SIGNATURE_PARAM, signature);
+
+      return requestBuilder.endpoint(endpointBuilder.build()).build();
+   }
+
+   protected String getPayloadHash() {
+      return UNSIGNED_PAYLOAD;
+   }
+}
diff --git a/apis/s3/src/main/java/org/jclouds/s3/filters/AwsHostNameUtils.java b/apis/s3/src/main/java/org/jclouds/s3/filters/AwsHostNameUtils.java
new file mode 100644
index 0000000000..a349aacd78
--- /dev/null
+++ b/apis/s3/src/main/java/org/jclouds/s3/filters/AwsHostNameUtils.java
@@ -0,0 +1,197 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ * Copyright(C) Inspur Corp. 2017,2018
+ * 
+ * COMPONENT NAME: jclouds
+ * FILE NAME: apis/s3/src/main/java/org/jclouds/s3/filters/AwsHostNameUtils.java
+ * DESCRIPTION: add this class for signature headers information of aws-s3 in China.
+ * 
+ * Change Log.
+ * 
+ * 29-07-2017 zreal,Inspur File creation.
+ * 
+ */
+package org.jclouds.s3.filters;
+
+import com.google.common.collect.ImmutableMap;
+
+import java.net.URI;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class AwsHostNameUtils {
+
+   private static final Pattern S3_ENDPOINT_PATTERN = Pattern.compile("^(?:.+\\.)?s3[.-]([a-z0-9-]+)$");
+
+   private static final Pattern STANDARD_CLOUDSEARCH_ENDPOINT_PATTERN = Pattern.compile("^(?:.+\\.)?([a-z0-9-]+)\\.cloudsearch$");
+
+   private static final Pattern EXTENDED_CLOUDSEARCH_ENDPOINT_PATTERN = Pattern.compile("^(?:.+\\.)?([a-z0-9-]+)\\.cloudsearch\\..+");
+
+   private static final ImmutableMap<String, String> HOST_REGEX_TO_REGION_MAPPINGS = new ImmutableMap.Builder<String, String>()
+      .put("(.+\\.)?s3\\.amazonaws\\.com", "us-east-1")
+      .put("(.+\\.)?s3-external-1\\.amazonaws\\.com", "us-east-1")
+      .put("(.+\\.)?s3-fips-us-gov-west-1\\.amazonaws\\.com", "us-gov-west-1")
+      .build();
+
+   /**
+    * Attempts to parse the region name from an endpoint based on conventions
+    * about the endpoint format.
+    *
+    * @param host      the hostname to parse
+    * @param serviceHint an optional hint about the service for the endpoint
+    * @return the region parsed from the hostname, or
+    * &quot;us-east-1&quot; if no region information
+    * could be found
+    */
+   public static String parseRegionName(final String host, final String serviceHint) {
+
+      String regionNameInInternalConfig = parseRegionNameByInternalConfig(host);
+      if (regionNameInInternalConfig != null) {
+         return regionNameInInternalConfig;
+      }
+
+      if (host.endsWith(".amazonaws.com")) {
+         int index = host.length() - ".amazonaws.com".length();
+         return parseStandardRegionName(host.substring(0, index));
+      }
+
+      if (serviceHint != null) {
+         if (serviceHint.equals("cloudsearch")
+            && !host.startsWith("cloudsearch.")) {
+
+            // CloudSearch domains use the nonstandard domain format
+            // [domain].[region].cloudsearch.[suffix].
+
+            Matcher matcher = EXTENDED_CLOUDSEARCH_ENDPOINT_PATTERN
+               .matcher(host);
+
+            if (matcher.matches()) {
+               return matcher.group(1);
+            }
+         }
+
+         // If we have a service hint, look for 'service.[region]' or
+         // 'service-[region]' in the endpoint's hostname.
+         Pattern pattern = Pattern.compile(
+            "^(?:.+\\.)?"
+               + Pattern.quote(serviceHint)
+               + "[.-]([a-z0-9-]+)\\."
+         );
+
+         Matcher matcher = pattern.matcher(host);
+         if (matcher.find()) {
+            return matcher.group(1);
+         }
+      }
+
+      // Endpoint is totally non-standard; guess us-east-1 for lack of a
+      // better option.
+
+      return "us-east-1";
+   }
+
+   /**
+    * Parses the region name from a standard (*.amazonaws.com) endpoint.
+    *
+    * @param fragment the portion of the endpoint excluding
+    *             &quot;.amazonaws.com&quot;
+    * @return the parsed region name (or &quot;us-east-1&quot; as a
+    * best guess if we can't tell for sure)
+    */
+   private static String parseStandardRegionName(final String fragment) {
+
+      Matcher matcher = S3_ENDPOINT_PATTERN.matcher(fragment);
+      if (matcher.matches()) {
+         // host was 'bucket.s3-[region].amazonaws.com'.
+         return matcher.group(1);
+      }
+
+      matcher = STANDARD_CLOUDSEARCH_ENDPOINT_PATTERN.matcher(fragment);
+      if (matcher.matches()) {
+         // host was 'domain.[region].cloudsearch.amazonaws.com'.
+         return matcher.group(1);
+      }
+
+      int index = fragment.lastIndexOf('.');
+      if (index == -1) {
+         // host was 'service.amazonaws.com', guess us-east-1
+         // for lack of a better option.
+         return "us-east-1";
+      }
+
+      // host was 'service.[region].amazonaws.com'.
+      String region = fragment.substring(index + 1);
+
+      // Special case for iam.us-gov.amazonaws.com, which is actually
+      // us-gov-west-1.
+      if ("us-gov".equals(region)) {
+         region = "us-gov-west-1";
+      }
+
+      return region;
+   }
+
+   /**
+    * @return the configured region name if the given host name matches any of
+    * the host-to-region mappings in the internal config; otherwise
+    * return null.
+    */
+   private static String parseRegionNameByInternalConfig(String host) {
+      for (Map.Entry<String, String> mapping : HOST_REGEX_TO_REGION_MAPPINGS.entrySet()) {
+         String hostNameRegex = mapping.getKey();
+         if (host.matches(hostNameRegex)) {
+            return mapping.getValue();
+         }
+      }
+
+      return null;
+   }
+
+   /**
+    * Parses the service name from an endpoint. Can only handle endpoints of
+    * the form 'service.[region.]amazonaws.com'.
+    * or
+    * bucket.s3.[region.]awazonaws.com
+    */
+   public static String parseServiceName(URI endpoint) {
+//      String host = endpoint.getHost();
+	   String host = endpoint.getPath();
+      if (!host.endsWith(".amazonaws.com") && !host.endsWith(".amazonaws.com.cn")) {
+         return "s3";  // cannot parse name, assume s3
+      }
+
+      String serviceAndRegion = host.substring(0, host.indexOf(".amazonaws.com"));
+
+      // Special cases for S3 endpoints with bucket names embedded.
+      if (serviceAndRegion.endsWith(".s3") || S3_ENDPOINT_PATTERN.matcher(serviceAndRegion).matches()) {
+         return "s3";
+      }
+
+      char separator = '.';
+
+      // If we don't detect a separator between service name and region, then
+      // assume that the region is not included in the hostname, and it's only
+      // the service name (ex: "http://iam.amazonaws.com").
+      if (serviceAndRegion.indexOf(separator) == -1) {
+         return serviceAndRegion;
+      }
+
+      return serviceAndRegion.substring(0, serviceAndRegion.indexOf(separator));
+   }
+}
diff --git a/apis/s3/src/main/java/org/jclouds/s3/filters/AwsSignatureV4Constants.java b/apis/s3/src/main/java/org/jclouds/s3/filters/AwsSignatureV4Constants.java
new file mode 100644
index 0000000000..9e1d2d786d
--- /dev/null
+++ b/apis/s3/src/main/java/org/jclouds/s3/filters/AwsSignatureV4Constants.java
@@ -0,0 +1,163 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ * Copyright(C) Inspur Corp. 2017,2018
+ * 
+ * COMPONENT NAME: jclouds
+ * FILE NAME: apis/s3/src/main/java/org/jclouds/s3/filters/AwsSignatureV4Constants.java
+ * DESCRIPTION: add this class for signature headers information of aws-s3 in China.
+ * 
+ * Change Log.
+ * 
+ * 29-07-2017 zreal,Inspur File creation.
+ * 
+ */
+package org.jclouds.s3.filters;
+
+/**
+ * AWS Signature Version 4 Constants.
+ */
+public abstract class AwsSignatureV4Constants {
+
+    /**
+     * AWS authorization header key
+     */
+   public static final String AUTHORIZATION_HEADER = "Authorization";
+
+   /**
+    * AWS content sha256 header key
+    */
+   public static final String AMZ_CONTENT_SHA256_HEADER = "x-amz-content-sha256";
+
+   /**
+    * AWS date header key
+    */
+   public static final String AMZ_DATE_HEADER = "X-Amz-Date";
+
+   /**
+    * AWS security token key
+    */
+   public static final String AMZ_SECURITY_TOKEN_HEADER = "X-Amz-Security-Token";
+
+   /**
+    * For AWS Signature Version 4, you set this parameter value to "AWS4-HMAC-SHA256".
+    */
+   public static final String AMZ_ALGORITHM_PARAM = "X-Amz-Algorithm";
+   /**
+    * This string identifies AWS Signature Version 4 (AWS4) and the HMAC-SHA256 algorithm (HMAC-SHA256).
+    */
+   public static final String AMZ_ALGORITHM_HMAC_SHA256 = "AWS4-HMAC-SHA256";
+
+   /**
+    * In addition to your access key ID, this parameter also provides scope information identifying the region and
+    * service for which the signature is valid.
+    * <p>This value should match the scope that you use to calculate the signing key, as discussed in the following section.</p>
+    * <p>The general form for this parameter value is as follows:</p>
+    * <code> &lt;your-access-key-id>/&lt;date>/&lt;AWS-region>/&lt;AWS-service>/aws4_request.</code>
+    * <p>
+    * For example:
+    * <code>AKIAIOSFODNN7EXAMPLE/20130721/us-east-1/s3/aws4_request.</code><br>
+    * For Amazon S3, the AWS-service string is "s3". For a list of AWS-region strings, go to Regions and Endpoints
+    * in the Amazon Web Services General Reference
+    * </p>
+    */
+   public static final String AMZ_CREDENTIAL_PARAM = "X-Amz-Credential";
+
+   /**
+    * This header can be used in the following scenarios:
+    * <ul>
+    * <li>Provide security tokens for Amazon DevPay operationsâ€”Each request that uses Amazon DevPay requires two
+    * x-amz-security-token headers: one for the product token and one for the user token. When Amazon S3 receives
+    * an authenticated request, it compares the computed signature with the provided signature.
+    * Improperly formatted multi-value headers used to calculate a signature can cause authentication issues</li>
+    * <li>Provide security token when using temporary security credentialsâ€”When making requests using temporary
+    * security credentials you obtained from IAM you must provide a security token using this header.
+    * To learn more about temporary security credentials, go to Making Requests.</li>
+    * </ul>
+    * This header is required for requests that use Amazon DevPay and requests that are signed using temporary security credentials.
+    */
+
+   public static final String AMZ_SECURITY_TOKEN_PARAM = AMZ_SECURITY_TOKEN_HEADER;
+
+   /**
+    * The date in ISO 8601 format, for example, 20130721T201207Z. This value must match the date value used to
+    * calculate the signature.
+    */
+   public static final String AMZ_DATE_PARAM = AMZ_DATE_HEADER;
+
+   /**
+    * Provides the time period, in seconds, for which the generated presigned URL is valid.
+    * <p> For example, 86400 (24 hours). This value is an integer. The minimum value you can set is 1,
+    * and the maximum is 604800 (seven days). </p>
+    * <p> A presigned URL can be valid for a maximum of seven days because the signing key you use in signature
+    * calculation is valid for up to seven days.</p>
+    */
+   public static final String AMZ_EXPIRES_PARAM = "X-Amz-Expires";
+
+   /**
+    * Lists the headers that you used to calculate the signature.
+    * <p> The HTTP host header is required. Any x-amz-* headers that you plan to add to the request are also required
+    * for signature calculation. </p>
+    * <p> In general, for added security, you should sign all the request headers that you plan to include in your
+    * request.</p>
+    */
+   public static final String AMZ_SIGNEDHEADERS_PARAM = "X-Amz-SignedHeaders";
+
+   /**
+    * X-Amz-Signature Provides the signature to authenticate your request.
+    * <p>This signature must match the signature Amazon S3 calculates; otherwise, Amazon S3 denies the request.
+    * For example, 733255ef022bec3f2a8701cd61d4b371f3f28c9f193a1f02279211d48d5193d7</p>
+    */
+   public static final String AMZ_SIGNATURE_PARAM = "X-Amz-Signature";
+
+   /**
+    * You don't include a payload hash in the Canonical Request, because when you create a presigned URL,
+    * <p> you don't know anything about the payload. Instead, you use a constant string "UNSIGNED-PAYLOAD".</p>
+    */
+   public static final String UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
+
+   /**
+    * SHA256 substitute marker used in place of x-amz-content-sha256 when
+    * employing chunked uploads
+    */
+   public static final String STREAMING_BODY_SHA256 = "STREAMING-AWS4-HMAC-SHA256-PAYLOAD";
+   public static final String CHUNK_STRING_TO_SIGN_PREFIX = "AWS4-HMAC-SHA256-PAYLOAD";
+
+   public static final String CLRF = "\r\n";
+
+   public static final String CHUNK_SIGNATURE_HEADER = ";chunk-signature=";
+   public static final int SIGNATURE_LENGTH = 64;
+   public static final byte[] FINAL_CHUNK = new byte[0];
+
+   /**
+    * Content-Encoding
+    * <p>
+    * Set the value to aws-chunked.<br>
+    * Amazon S3 supports multiple content encodings, for example,<br>
+    * Content-Encoding : aws-chunked, gzip<br>
+    * That is, you can specify your custom content-encoding when using Signature Version 4 streaming API.
+    * </p>
+    */
+   public static final String CONTENT_ENCODING_HEADER_AWS_CHUNKED = "aws-chunked";
+   /**
+    * 'x-amz-decoded-content-length' is used to transmit the actual
+    */
+   public static final String AMZ_DECODED_CONTENT_LENGTH_HEADER = "x-amz-decoded-content-length";
+
+   private AwsSignatureV4Constants() {
+   }
+}
diff --git a/apis/s3/src/main/java/org/jclouds/s3/filters/ChunkedUploadException.java b/apis/s3/src/main/java/org/jclouds/s3/filters/ChunkedUploadException.java
new file mode 100644
index 0000000000..faac1ffb01
--- /dev/null
+++ b/apis/s3/src/main/java/org/jclouds/s3/filters/ChunkedUploadException.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ * Copyright(C) Inspur Corp. 2017,2018
+ * 
+ * COMPONENT NAME: jclouds
+ * FILE NAME: apis/s3/src/main/java/org/jclouds/s3/filters/ChunkedUploadException.java
+ * DESCRIPTION: add this class for signature headers information of aws-s3 in China.
+ * 
+ * Change Log.
+ * 
+ * 29-07-2017 zreal,Inspur File creation.
+ * 
+ */
+package org.jclouds.s3.filters;
+
+public class ChunkedUploadException extends RuntimeException {
+   public ChunkedUploadException(String error, Exception e) {
+      super(error, e);
+   }
+}
diff --git a/apis/s3/src/main/java/org/jclouds/s3/filters/ChunkedUploadPayload.java b/apis/s3/src/main/java/org/jclouds/s3/filters/ChunkedUploadPayload.java
new file mode 100644
index 0000000000..8491c45bef
--- /dev/null
+++ b/apis/s3/src/main/java/org/jclouds/s3/filters/ChunkedUploadPayload.java
@@ -0,0 +1,229 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ * Copyright(C) Inspur Corp. 2017,2018
+ * 
+ * COMPONENT NAME: jclouds
+ * FILE NAME: apis/s3/src/main/java/org/jclouds/s3/filters/ChunkedUploadPayload.java
+ * DESCRIPTION: add this class for signature headers information of aws-s3 in China.
+ * 
+ * Change Log.
+ * 
+ * 29-07-2017 zreal,Inspur File creation.
+ * 
+ */
+package org.jclouds.s3.filters;
+
+import com.google.common.io.ByteProcessor;
+import com.google.common.io.ByteStreams;
+import org.jclouds.http.HttpException;
+import org.jclouds.io.MutableContentMetadata;
+import org.jclouds.io.Payload;
+import org.jclouds.io.payloads.BaseMutableContentMetadata;
+import org.jclouds.io.payloads.BasePayload;
+
+import java.io.BufferedInputStream;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.SequenceInputStream;
+import java.util.Enumeration;
+
+import static com.google.common.base.Charsets.UTF_8;
+import static com.google.common.io.ByteStreams.readBytes;
+import static org.jclouds.s3.filters.Aws4SignerBase.hash;
+import static org.jclouds.s3.filters.Aws4SignerBase.hex;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.CHUNK_SIGNATURE_HEADER;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.CHUNK_STRING_TO_SIGN_PREFIX;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.CLRF;
+import static org.jclouds.s3.filters.AwsSignatureV4Constants.FINAL_CHUNK;
+import static org.jclouds.util.Strings2.toInputStream;
+
+public class ChunkedUploadPayload extends BasePayload<Payload> {
+   private static final byte[] TRAILER = CLRF.getBytes(UTF_8);
+
+   private final Payload payload;
+   private final int chunkedBlockSize;
+   private final String timestamp;
+   private final String scope;
+   private final ByteProcessor<byte[]> hmacSHA256;
+   private String lastComputedSignature;
+
+   public ChunkedUploadPayload(Payload payload, int blockSize, String timestamp, String scope,
+         ByteProcessor<byte[]> hmacSHA256, String seedSignature) {
+      super(payload);
+      this.payload = payload;
+      this.chunkedBlockSize = blockSize;
+      this.timestamp = timestamp;
+      this.scope = scope;
+      this.hmacSHA256 = hmacSHA256;
+      this.lastComputedSignature = seedSignature;
+
+      // init content metadata
+      MutableContentMetadata contentMetadata = BaseMutableContentMetadata.fromContentMetadata(
+            payload.getContentMetadata());
+      long totalLength = Aws4SignerForChunkedUpload.calculateChunkedContentLength(
+            payload.getContentMetadata().getContentLength(),
+            chunkedBlockSize);
+      contentMetadata.setContentLength(totalLength);
+      this.setContentMetadata(contentMetadata);
+   }
+
+   /**
+    * Returns a chunk for upload consisting of the signed 'header' or chunk
+    * prefix plus the user data. The signature of the chunk incorporates the
+    * signature of the previous chunk (or, if the first chunk, the signature of
+    * the headers portion of the request).
+    *
+    * @param userDataLen The length of the user data contained in userData
+    * @param userData   Contains the user data to be sent in the upload chunk
+    * @return A new buffer of data for upload containing the chunk header plus
+    * user data
+    */
+   protected byte[] constructSignedChunk(int userDataLen, byte[] userData) {
+      // to keep our computation routine signatures simple, if the userData
+      // buffer contains less data than it could, shrink it. Note the special case
+      // to handle the requirement that we send an empty chunk to complete
+      // our chunked upload.
+      byte[] dataToChunk;
+      if (userDataLen == 0) {
+         dataToChunk = FINAL_CHUNK;
+      } else {
+         if (userDataLen < userData.length) {
+            // shrink the chunkdata to fit
+            dataToChunk = new byte[userDataLen];
+            System.arraycopy(userData, 0, dataToChunk, 0, userDataLen);
+         } else {
+            dataToChunk = userData;
+         }
+      }
+
+      // string(IntHexBase(chunk-size)) + ";chunk-signature=" + signature + \r\n + chunk-data + \r\n
+      StringBuilder chunkHeader = new StringBuilder();
+
+      // start with size of user data
+      // IntHexBase(chunk-size)
+      chunkHeader.append(Integer.toHexString(dataToChunk.length));
+
+      // chunk-signature
+
+      // nonsig-extension; we have none in these samples
+      String nonsigExtension = "";
+
+      // if this is the first chunk, we package it with the signing result
+      // of the request headers, otherwise we use the cached signature
+      // of the previous chunk
+
+      // sig-extension
+      StringBuilder buffer = new StringBuilder();
+      buffer.append(CHUNK_STRING_TO_SIGN_PREFIX);
+      buffer.append("\n");
+      buffer.append(timestamp).append("\n");
+      buffer.append(scope).append("\n");
+      buffer.append(lastComputedSignature).append("\n");
+      buffer.append(hex(hash(nonsigExtension))).append("\n");
+      buffer.append(hex(hash(dataToChunk)));
+
+      String chunkStringToSign = buffer.toString();
+
+      // compute the V4 signature for the chunk
+      String chunkSignature;
+      try {
+         chunkSignature = hex(readBytes(toInputStream(chunkStringToSign), hmacSHA256));
+      } catch (IOException e) {
+         throw new HttpException("hmac sha256 chunked signature error");
+      }
+
+      // cache the signature to include with the next chunk's signature computation
+      lastComputedSignature = chunkSignature;
+
+      // construct the actual chunk, comprised of the non-signed extensions, the
+      // 'headers' we just signed and their signature, plus a newline then copy
+      // that plus the user's data to a payload to be written to the request stream
+      chunkHeader.append(nonsigExtension + CHUNK_SIGNATURE_HEADER + chunkSignature);
+      chunkHeader.append(CLRF);
+
+      byte[] header = chunkHeader.toString().getBytes(UTF_8);
+      byte[] signedChunk = new byte[header.length + dataToChunk.length + TRAILER.length];
+      System.arraycopy(header, 0, signedChunk, 0, header.length);
+      // chunk-data
+      System.arraycopy(dataToChunk, 0, signedChunk, header.length, dataToChunk.length);
+      System.arraycopy(TRAILER, 0, signedChunk, header.length + dataToChunk.length, TRAILER.length);
+
+      // this is the total data for the chunk that will be sent to the request stream
+      return signedChunk;
+   }
+
+   @Override
+   public void release() {
+      this.payload.release();
+   }
+
+   @Override
+   public boolean isRepeatable() {
+      return this.payload.isRepeatable();
+   }
+
+   @Override
+   public InputStream openStream() throws IOException {
+      return new SequenceInputStream(new ChunkedInputStreamEnumeration(this.payload.openStream(), chunkedBlockSize));
+   }
+
+   private class ChunkedInputStreamEnumeration implements Enumeration<InputStream> {
+      private final InputStream inputStream;
+      private boolean lastChunked;
+      private byte[] buffer;
+
+      ChunkedInputStreamEnumeration(InputStream inputStream, int chunkedBlockSize) {
+         this.inputStream = new BufferedInputStream(inputStream, chunkedBlockSize);
+         buffer = new byte[chunkedBlockSize];
+         lastChunked = false;
+      }
+
+      @Override
+      public boolean hasMoreElements() {
+         return !lastChunked;
+      }
+
+      @Override
+      public InputStream nextElement() {
+         int bytesRead;
+         try {
+            bytesRead = ByteStreams.read(inputStream, buffer, 0, buffer.length);
+         } catch (IOException e) {
+            // IO EXCEPTION
+            throw new ChunkedUploadException("read from input stream error", e);
+         }
+
+         // buffer
+         byte[] chunk;
+
+         // ByteStreams.read(InputStream, byte[], int, int) returns the number of bytes read
+         // InputStream.read(byte[], int, int) returns -1 if the end of the stream has been reached.
+         if (bytesRead > 0) {
+            // process into a chunk
+            chunk = constructSignedChunk(bytesRead, buffer);
+         } else {
+            // construct last chunked block
+            chunk = constructSignedChunk(0, buffer);
+            lastChunked = true;
+         }
+         return new ByteArrayInputStream(chunk);
+      }
+   }
+
+}
diff --git a/apis/s3/src/main/java/org/jclouds/s3/filters/RequestAuthorizeSignature.java b/apis/s3/src/main/java/org/jclouds/s3/filters/RequestAuthorizeSignature.java
index e8009e46b8..ad0faf3640 100644
--- a/apis/s3/src/main/java/org/jclouds/s3/filters/RequestAuthorizeSignature.java
+++ b/apis/s3/src/main/java/org/jclouds/s3/filters/RequestAuthorizeSignature.java
@@ -28,12 +28,17 @@ import static org.jclouds.s3.reference.S3Constants.PROPERTY_S3_SERVICE_PATH;
 import static org.jclouds.s3.reference.S3Constants.PROPERTY_S3_VIRTUAL_HOST_BUCKETS;
 import static org.jclouds.util.Strings2.toInputStream;
 
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import java.security.cert.CertificateException;
 import java.util.Collection;
+import java.util.Date;
 import java.util.Locale;
 import java.util.Map.Entry;
 import java.util.Set;
 
 import javax.annotation.Resource;
+import javax.crypto.Mac;
 import javax.inject.Inject;
 import javax.inject.Named;
 import javax.inject.Provider;
@@ -44,6 +49,7 @@ import org.jclouds.aws.domain.SessionCredentials;
 import org.jclouds.crypto.Crypto;
 import org.jclouds.date.TimeStamp;
 import org.jclouds.domain.Credentials;
+import org.jclouds.encryption.internal.JCECrypto;
 import org.jclouds.http.HttpException;
 import org.jclouds.http.HttpRequest;
 import org.jclouds.http.HttpRequestFilter;
@@ -51,11 +57,14 @@ import org.jclouds.http.HttpUtils;
 import org.jclouds.http.internal.SignatureWire;
 import org.jclouds.logging.Logger;
 import org.jclouds.rest.RequestSigner;
+import org.jclouds.s3.filters.Aws4SignerBase.ServiceAndRegion;
+import org.jclouds.s3.filters.Aws4SignerBase.ServiceAndRegion.AWSServiceAndRegion;
 import org.jclouds.s3.util.S3Utils;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Strings;
 import com.google.common.base.Supplier;
+import com.google.common.base.Suppliers;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimap;
@@ -110,23 +119,80 @@ public class RequestAuthorizeSignature implements HttpRequestFilter, RequestSign
       this.utils = utils;
    }
 
+   private String dataToSign = "";
    public HttpRequest filter(HttpRequest request) throws HttpException {
-      request = replaceDateHeader(request);
-      Credentials current = creds.get();
-      if (current instanceof SessionCredentials) {
-         request = replaceSecurityTokenHeader(request, SessionCredentials.class.cast(current));
-      }
-      String signature = calculateSignature(createStringToSign(request));
-      request = replaceAuthorizationHeader(request, signature);
-      utils.logRequest(signatureLog, request, "<<");
-      return request;
-   }
+      Credentials current = this.creds.get();
+      if (current.identity.length() != RegionHandler.OSS_ACCESS_KEY_ID_LENGTH) {
+         /*handle the aws-s3 request */
+         Supplier<Date> timestampProvider = Suppliers.ofInstance(new Date(timeStampProvider.get()));
+         String userDataBlockSize = System.getProperty("user.data.block.size");
+         int sliceSize = 262144; // the dafault value for block size
+         if (userDataBlockSize != null) {
+            sliceSize  = Integer.valueOf(userDataBlockSize);
+         }
+         String endpoint = request.getEndpoint().getHost();
+         ServiceAndRegion serviceAndRegion = new AWSServiceAndRegion(endpoint);
+         Aws4SignerForAuthorizationHeader asah4 = 
+                       new Aws4SignerForAuthorizationHeader(this.signatureWire, this.isVhostStyle, this.headerTag, this.creds, timestampProvider, serviceAndRegion, this.crypto);
+         Aws4SignerForChunkedUpload ascu4 = 
+                       new Aws4SignerForChunkedUpload(this.signatureWire, this.headerTag, sliceSize, this.creds, timestampProvider, serviceAndRegion, this.crypto);
+         RequestAuthorizeSignatureV4 ras4 = 
+                       new RequestAuthorizeSignatureV4(asah4, ascu4, null);
+         request = ras4.filter(request);
+         return request;  
+      } else {
+          request = replaceDateHeader(request);
+          if (current instanceof SessionCredentials) {
+             request = replaceSecurityTokenHeader(request, SessionCredentials.class.cast(current));
+          }
+          /* solve the problem about getting the oss bucket info. */
+          if (current.identity.length() == RegionHandler.OSS_ACCESS_KEY_ID_LENGTH) {
+             if (request.getMethod().toUpperCase().equals("HEAD")) {
+                request = request.toBuilder().method("GET").build();
+             }
+          }
+          dataToSign = createStringToSign(request);
+          //output dataToSign
+          String signature = calculateSignature(dataToSign);
+          request = replaceAuthorizationHeader(request, signature);
+          utils.logRequest(signatureLog, request, "<<");
+          return request;
+       }
+    }
 
    HttpRequest replaceSecurityTokenHeader(HttpRequest request, SessionCredentials current) {
       return request.toBuilder().replaceHeader("x-amz-security-token", current.getSessionToken()).build();
    }
 
    protected HttpRequest replaceAuthorizationHeader(HttpRequest request, String signature) {
+      Credentials credentials = creds.get();
+      /* oss accesskeyid and secretaccesskey */
+      String accesskeyid = credentials.identity;
+      String secretaccesskey = credentials.credential;
+      if ((accesskeyid != null) && (accesskeyid.length() == RegionHandler.OSS_ACCESS_KEY_ID_LENGTH)) {		   
+         /**
+         * if using oss, then create the oss header  
+         */
+         Crypto crypto = null;
+         Mac mac = null;
+         try {
+            crypto = new JCECrypto();
+            mac = crypto.hmacSHA1(secretaccesskey.getBytes());
+         } catch (NoSuchAlgorithmException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+         } catch (CertificateException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+         } catch (InvalidKeyException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+         }
+         String ossSignature = base64().encode(mac.doFinal(dataToSign.getBytes()));
+         String ossAuthorization = "OSS " + accesskeyid + ":" + ossSignature;
+         request = request.toBuilder().replaceHeader(HttpHeaders.AUTHORIZATION, ossAuthorization).build();
+         return request;	   
+      }
       request = request.toBuilder()
             .replaceHeader(HttpHeaders.AUTHORIZATION, authTag + " " + creds.get().identity + ":" + signature).build();
       return request;
@@ -150,7 +216,15 @@ public class RequestAuthorizeSignature implements HttpRequestFilter, RequestSign
       if (canonicalizedHeaders.containsKey("x-" + headerTag + "-date")) {
          canonicalizedHeaders.removeAll("date");
       }
-
+      /*
+       * test provider is aws-s3 or not.
+       */
+      Credentials credentials = creds.get();
+	   /* oss accesskeyid and secretaccesskey */
+	   String accesskeyid = credentials.identity;
+      if ((accesskeyid != null) && (accesskeyid.length() != RegionHandler.OSS_ACCESS_KEY_ID_LENGTH)) {
+    	  appendAmzHeaders(canonicalizedHeaders, buffer);
+      }
       appendAmzHeaders(canonicalizedHeaders, buffer);
       appendBucketName(request, buffer);
       appendUriPath(request, buffer);
diff --git a/apis/s3/src/main/java/org/jclouds/s3/filters/RequestAuthorizeSignatureV4.java b/apis/s3/src/main/java/org/jclouds/s3/filters/RequestAuthorizeSignatureV4.java
new file mode 100644
index 0000000000..1a24745bff
--- /dev/null
+++ b/apis/s3/src/main/java/org/jclouds/s3/filters/RequestAuthorizeSignatureV4.java
@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ * Copyright(C) Inspur Corp. 2017,2018
+ * 
+ * COMPONENT NAME: jclouds
+ * FILE NAME: apis/s3/src/main/java/org/jclouds/s3/filters/RequestAuthorizeSignatureV4.java
+ * DESCRIPTION: add this class for signature headers information of aws-s3 in China.
+ * 
+ * Change Log.
+ * 
+ * 29-07-2017 zreal,Inspur File creation.
+ * 
+ */
+package org.jclouds.s3.filters;
+
+import com.google.common.reflect.TypeToken;
+import org.jclouds.http.HttpException;
+import org.jclouds.http.HttpRequest;
+import org.jclouds.io.Payload;
+import org.jclouds.rest.internal.GeneratedHttpRequest;
+import org.jclouds.s3.S3Client;
+
+public class RequestAuthorizeSignatureV4 {
+
+   private static final String PUT_OBJECT_METHOD = "putObject";
+   private static final TypeToken<S3Client> S3_CLIENT_TYPE = new TypeToken<S3Client>() {
+   };
+
+   private final Aws4SignerForAuthorizationHeader signerForAuthorizationHeader;
+   private final Aws4SignerForChunkedUpload signerForChunkedUpload;
+   private final Aws4SignerForQueryString signerForQueryString;
+
+   public RequestAuthorizeSignatureV4(Aws4SignerForAuthorizationHeader signerForAuthorizationHeader,
+         Aws4SignerForChunkedUpload signerForChunkedUpload,
+         Aws4SignerForQueryString signerForQueryString) {
+      this.signerForAuthorizationHeader = signerForAuthorizationHeader;
+      this.signerForChunkedUpload = signerForChunkedUpload;
+      this.signerForQueryString = signerForQueryString;
+   }
+
+   public HttpRequest filter(HttpRequest request) throws HttpException {
+      // request use chunked upload
+      if (useChunkedUpload(request)) {
+         return signForChunkedUpload(request);
+      }
+      return signForAuthorizationHeader(request);
+   }
+
+   /**
+    * returns true, if use AWS S3 chunked upload.
+    */
+   protected boolean useChunkedUpload(HttpRequest request) {
+      // only S3Client putObject method, payload not null, content-length > 0 and cannot repeatable
+      if (!GeneratedHttpRequest.class.isAssignableFrom(request.getClass())) {
+         return false;
+      }
+      GeneratedHttpRequest req = GeneratedHttpRequest.class.cast(request);
+
+      // s3 client type and method name is putObject
+      if (S3_CLIENT_TYPE.equals(req.getInvocation().getInvokable().getOwnerType()) &&
+            !PUT_OBJECT_METHOD.equals(req.getInvocation().getInvokable().getName())) {
+         return false;
+      }
+
+      Payload payload = req.getPayload();
+
+      // check payload null or payload.contentMetadata null
+      if (payload == null || payload.getContentMetadata() == null) {
+         return false;
+      }
+
+      Long contentLength = payload.getContentMetadata().getContentLength();
+
+      if (contentLength == null) {
+         return false;
+      }
+
+      return contentLength > 0L && !payload.isRepeatable();
+   }
+
+   protected HttpRequest signForAuthorizationHeader(HttpRequest request) {
+      return signerForAuthorizationHeader.sign(request);
+   }
+
+   protected HttpRequest signForChunkedUpload(HttpRequest request) {
+      return signerForChunkedUpload.sign(request);
+   }
+
+   // Authenticating Requests by Using Query Parameters (AWS Signature Version 4)
+
+   /**
+    * Using query parameters to authenticate requests is useful when you want to express a request entirely in a URL.
+    * This method is also referred as presigning a URL. Presigned URLs enable you to grant temporary access to your
+    * Amazon S3 resources. The end user can then enter the presigned URL in his or her browser to access the specific
+    * Amazon S3 resource. You can also use presigned URLs to embed clickable links in HTML.
+    * <p/>
+    * For example, you might store videos in an Amazon S3 bucket and make them available on your website by using presigned URLs.
+    * Identifies the version of AWS Signature and the algorithm that you used to calculate the signature.
+    */
+   public HttpRequest signForTemporaryAccess(HttpRequest request, long timeInSeconds) {
+      return signerForQueryString.sign(request, timeInSeconds);
+   }
+
+
+}
diff --git a/apis/s3/src/main/java/org/jclouds/s3/functions/BindRegionToXmlPayload.java b/apis/s3/src/main/java/org/jclouds/s3/functions/BindRegionToXmlPayload.java
index 732ff659f9..61884ab0b4 100644
--- a/apis/s3/src/main/java/org/jclouds/s3/functions/BindRegionToXmlPayload.java
+++ b/apis/s3/src/main/java/org/jclouds/s3/functions/BindRegionToXmlPayload.java
@@ -75,7 +75,16 @@ public class BindRegionToXmlPayload extends BindToStringPayload {
          value = constraint;
       } else {
          logger.warn("region %s not in %s ", constraint, regions);
-         value = constraint;
+         value = constraint; // the original code
+         logger.info("region constraintconstraint is %s ", constraint);
+         logger.info("region value is %s ", value);
+         if (!value.startsWith("http")) {
+            String payload = String
+            .format(
+               "<CreateBucketConfiguration><LocationConstraint>%s</LocationConstraint></CreateBucketConfiguration>",
+               value);
+         request = super.bindToRequest(request, payload);
+         request.getPayload().getContentMetadata().setContentType(MediaType.TEXT_XML);
       }
       String payload = String
             .format(
diff --git a/apis/s3/src/main/java/org/jclouds/s3/xml/AccessControlListHandler.java b/apis/s3/src/main/java/org/jclouds/s3/xml/AccessControlListHandler.java
index 8a55672795..dbc59a9847 100644
--- a/apis/s3/src/main/java/org/jclouds/s3/xml/AccessControlListHandler.java
+++ b/apis/s3/src/main/java/org/jclouds/s3/xml/AccessControlListHandler.java
@@ -24,9 +24,11 @@ import org.jclouds.http.functions.ParseSax;
 import org.jclouds.s3.domain.AccessControlList;
 import org.jclouds.s3.domain.AccessControlList.CanonicalUserGrantee;
 import org.jclouds.s3.domain.AccessControlList.EmailAddressGrantee;
+import org.jclouds.s3.domain.AccessControlList.OssPermissionGrantee;
 import org.jclouds.s3.domain.AccessControlList.Grantee;
 import org.jclouds.s3.domain.AccessControlList.GroupGrantee;
 import org.jclouds.s3.domain.CanonicalUser;
+import org.jclouds.util.RegionHandler;
 import org.xml.sax.Attributes;
 
 /**
@@ -71,6 +73,10 @@ public class AccessControlListHandler extends ParseSax.HandlerWithResult<AccessC
             currentGrantee = new GroupGrantee(URI.create(currentId));
          }
       } else if (qName.equals("Grant")) {
+         if (RegionHandler.CSP_REGION.isEmpty() || RegionHandler.CSP_REGION.contains("oss")) {
+            currentPermission = currentOrNull(currentText);
+            currentGrantee = new OssPermissionGrantee(acl.getOwner().getId());
+         }
          acl.addPermission(currentGrantee, currentPermission);
       }
 
diff --git a/apis/s3/src/main/java/org/jclouds/s3/xml/ListBucketHandler.java b/apis/s3/src/main/java/org/jclouds/s3/xml/ListBucketHandler.java
index c5fdb73461..136b34a2e5 100644
--- a/apis/s3/src/main/java/org/jclouds/s3/xml/ListBucketHandler.java
+++ b/apis/s3/src/main/java/org/jclouds/s3/xml/ListBucketHandler.java
@@ -108,7 +108,8 @@ public class ListBucketHandler extends ParseSax.HandlerWithResult<ListBucketResp
          builder.owner(currentOwner);
          currentOwner = null;
       } else if (qName.equals("StorageClass")) {
-         builder.storageClass(ObjectMetadata.StorageClass.valueOf(currentOrNull(currentText)));
+         /*toUpperCase is added for oss, aws-s3 is uppercase, but oss is lowcase */
+         builder.storageClass(ObjectMetadata.StorageClass.valueOf(currentOrNull(currentText).toUpperCase()));
       } else if (qName.equals("Contents")) {
          contents.add(builder.build());
          builder = new ObjectMetadataBuilder().bucket(bucketName);
diff --git a/apis/sts/src/main/java/org/jclouds/aws/domain/Region.java b/apis/sts/src/main/java/org/jclouds/aws/domain/Region.java
index 1a3a9c7bbe..86533668d1 100644
--- a/apis/sts/src/main/java/org/jclouds/aws/domain/Region.java
+++ b/apis/sts/src/main/java/org/jclouds/aws/domain/Region.java
@@ -110,18 +110,53 @@ public class Region {
     */
    public static final String AP_NORTHEAST_1 = "ap-northeast-1";
 
+   /**
+    * Region in Beijing, launched early 2014. This region improves latency for China users
+    */
+   public static final String CN_NORTH_1 = "cn-north-1";
+
+   /**
+    * oss region
+    * Region 
+    */
+   public static final String OSS_CN_SHANGHAI = "oss-cn-shanghai";
+   public static final String OSS_CN_HANGZHOU = "oss-cn-hangzhou";
+   public static final String OSS_CN_QINGDAO = "oss-cn-qingdao";
+   public static final String OSS_CN_BEIJING = "oss-cn-beijing";
+   public static final String OSS_CN_ZHANGJIAKOU = "oss-cn-zhangjiakou";
+   public static final String OSS_CN_SHENZHEN = "oss-cn-shenzhen";
+   public static final String OSS_CN_HONGKONG = "oss-cn-hongkong";
+   //Silicon Valley
+   public static final String OSS_US_WEST_1 = "oss-us-west-1";
+   //Virginia
+   public static final String OSS_US_EAST_1 = "oss-us-east-1";
+   //Singapore
+   public static final String OSS_AP_SOUTHEAST_1 = "oss-ap-southeast-1";
+   //Sydney
+   public static final String OSS_AP_SOUTHEAST_2 = "oss-ap-southeast-2";
+   //Japan
+   public static final String OSS_AP_NORTHEAST_1 = "oss-ap-northeast-1";
+   //Frankfurt
+   public static final String OSS_EU_CENTRAL = "oss-eu-central-1";
+   //Dubai
+   public static final String OSS_ME_EAST_1 = "oss-me-east-1";
+
    public static final Set<String> DEFAULT_S3 = ImmutableSet.of(US_STANDARD, US_WEST_1, US_WEST_2, EU_WEST_1, SA_EAST_1,
-         AP_SOUTHEAST_1, AP_SOUTHEAST_2, AP_NORTHEAST_1);
+         AP_SOUTHEAST_1, AP_SOUTHEAST_2, AP_NORTHEAST_1, CN_NORTH_1, 
+         OSS_CN_SHANGHAI, OSS_CN_HANGZHOU, OSS_CN_QINGDAO, OSS_CN_BEIJING, OSS_CN_ZHANGJIAKOU, OSS_CN_SHENZHEN, OSS_CN_HONGKONG, 
+         OSS_US_WEST_1, OSS_US_EAST_1, OSS_AP_SOUTHEAST_1, OSS_AP_SOUTHEAST_2, OSS_AP_NORTHEAST_1, OSS_EU_CENTRAL, OSS_ME_EAST_1);
 
    public static final Set<String> DEFAULT_REGIONS = ImmutableSet.of(US_EAST_1, US_WEST_1, US_WEST_2, SA_EAST_1,
-         EU_WEST_1, EU_CENTRAL_1, AP_SOUTHEAST_1, AP_SOUTHEAST_2, AP_NORTHEAST_1);
+         EU_WEST_1, EU_CENTRAL_1, AP_SOUTHEAST_1, AP_SOUTHEAST_2, AP_NORTHEAST_1, CN_NORTH_1,
+         OSS_CN_SHANGHAI, OSS_CN_HANGZHOU, OSS_CN_QINGDAO, OSS_CN_BEIJING, OSS_CN_ZHANGJIAKOU, OSS_CN_SHENZHEN, OSS_CN_HONGKONG, 
+         OSS_US_WEST_1, OSS_US_EAST_1, OSS_AP_SOUTHEAST_1, OSS_AP_SOUTHEAST_2, OSS_AP_NORTHEAST_1, OSS_EU_CENTRAL, OSS_ME_EAST_1);
 
    public static Properties regionPropertiesS3() {
 
       Properties properties = regionProperties();
       properties.setProperty(PROPERTY_REGIONS, Joiner.on(',').join(DEFAULT_S3));
       // note that due to US_STANDARD the codes include US instead of US-VA
-      properties.setProperty(PROPERTY_ISO3166_CODES, "US,US-CA,US-OR,BR-SP,IE,SG,AU-NSW,JP-13");
+      properties.setProperty(PROPERTY_ISO3166_CODES, "US,US-CA,US-OR,BR-SP,IE,SG,AU-NSW,JP-13,CN-11");
       properties.setProperty(PROPERTY_REGION + "." + US_STANDARD + "." + ISO3166_CODES, "US");
       properties.setProperty(PROPERTY_REGION + "." + EU_WEST_1 + "." + ISO3166_CODES, "IE");
       return properties;
@@ -130,7 +165,7 @@ public class Region {
    public static Properties regionProperties() {
       Properties properties = new Properties();
       properties.setProperty(PROPERTY_REGIONS, Joiner.on(',').join(DEFAULT_REGIONS));
-      properties.setProperty(PROPERTY_ISO3166_CODES, "US-VA,US-CA,US-OR,BR-SP,IE,DE-HE,SG,AU-NSW,JP-13");
+      properties.setProperty(PROPERTY_ISO3166_CODES, "US-VA,US-CA,US-OR,BR-SP,IE,DE-HE,SG,AU-NSW,JP-13,CN-11");
       properties.setProperty(PROPERTY_REGION + "." + US_EAST_1 + "." + ISO3166_CODES, "US-VA");
       properties.setProperty(PROPERTY_REGION + "." + US_WEST_1 + "." + ISO3166_CODES, "US-CA");
       properties.setProperty(PROPERTY_REGION + "." + US_WEST_2 + "." + ISO3166_CODES, "US-OR");
@@ -140,6 +175,7 @@ public class Region {
       properties.setProperty(PROPERTY_REGION + "." + AP_SOUTHEAST_1 + "." + ISO3166_CODES, "SG");
       properties.setProperty(PROPERTY_REGION + "." + AP_SOUTHEAST_2 + "." + ISO3166_CODES, "AU-NSW");
       properties.setProperty(PROPERTY_REGION + "." + AP_NORTHEAST_1 + "." + ISO3166_CODES, "JP-13");
+      properties.setProperty(PROPERTY_REGION + "." + CN_NORTH_1 + "." + ISO3166_CODES, "CN-11");
       return properties;
    }
 }
diff --git a/core/src/main/java/org/jclouds/http/internal/BaseHttpCommandExecutorService.java b/core/src/main/java/org/jclouds/http/internal/BaseHttpCommandExecutorService.java
index dd2f03d262..afe16a64a0 100644
--- a/core/src/main/java/org/jclouds/http/internal/BaseHttpCommandExecutorService.java
+++ b/core/src/main/java/org/jclouds/http/internal/BaseHttpCommandExecutorService.java
@@ -23,7 +23,11 @@ import static org.jclouds.http.HttpUtils.releasePayload;
 import static org.jclouds.http.HttpUtils.wirePayloadIfEnabled;
 import static org.jclouds.util.Throwables2.getFirstThrowableOfType;
 
+import java.io.FileNotFoundException;
 import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.text.SimpleDateFormat;
+import java.util.Date;
 import java.util.Set;
 
 import javax.annotation.Resource;
@@ -92,9 +96,12 @@ public abstract class BaseHttpCommandExecutorService<Q> implements HttpCommandEx
             logger.debug("Sending request %s: %s", request.hashCode(), request.getRequestLine());
             wirePayloadIfEnabled(wire, request);
             utils.logRequest(headerLog, request, ">>");
+            logger.debug("request content: %s", request.toString());
             nativeRequest = convert(request);
             response = invoke(nativeRequest);
 
+            logger.debug("response content: %s", response.toString());
+            logger.debug("Receiving response %s: %s", response.getHeaders().get("x-oss-request-id").toString(), response.toString());
             logger.debug("Receiving response %s: %s", request.hashCode(), response.getStatusLine());
             utils.logResponse(headerLog, response, "<<");
             if (response.getPayload() != null && wire.enabled())
@@ -160,5 +167,47 @@ public abstract class BaseHttpCommandExecutorService<Q> implements HttpCommandEx
    protected abstract HttpResponse invoke(Q nativeRequest) throws IOException, InterruptedException;
 
    protected abstract void cleanup(Q nativeRequest);
+   /**
+   * append the content to the file
+   */
+   public static void appendFile(String content, String className){	
+      String fileName = "/dumps/cloud/jcloud.trace";
+      String osType = System.getProperty("os.name");
+      if (osType.toLowerCase().contains("windows")) {
+         fileName = "E://jcloud.trace";
+      }
+      RandomAccessFile raf = null;
+      try {
+         content = getTimestamp() + "  " + className + "  " + content + "\r\n";
+         raf = new RandomAccessFile(fileName, "rw");
+         raf.seek(raf.length());
+         String temp = new String(content.getBytes());
+         raf.writeBytes(temp);
+       } catch (FileNotFoundException e) {
+       // TODO Auto-generated catch block
+       e.printStackTrace();
+       } catch (IOException e) {
+       // TODO Auto-generated catch block
+       e.printStackTrace();
+       } finally {
+            try {
+            raf.close();
+            } catch (IOException e) {
+               // TODO Auto-generated catch block
+               e.printStackTrace();
+            }
+       }
+   }
+   /**
+    * get the timestamp
+    * @return time
+   */
+   private static String getTimestamp(){
+      Date currentTime = new Date(System.currentTimeMillis());
+      SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
+      return sdf.format(currentTime);
+    }
+}
+
 
 }
diff --git a/core/src/main/java/org/jclouds/rest/internal/RestAnnotationProcessor.java b/core/src/main/java/org/jclouds/rest/internal/RestAnnotationProcessor.java
index 74b1ac17c4..3dbd524a40 100644
--- a/core/src/main/java/org/jclouds/rest/internal/RestAnnotationProcessor.java
+++ b/core/src/main/java/org/jclouds/rest/internal/RestAnnotationProcessor.java
@@ -64,6 +64,7 @@ import org.jclouds.Constants;
 import org.jclouds.http.HttpRequest;
 import org.jclouds.http.HttpRequestFilter;
 import org.jclouds.http.HttpUtils;
+import org.jclouds.http.Uris;
 import org.jclouds.http.Uris.UriBuilder;
 import org.jclouds.http.filters.StripExpectHeader;
 import org.jclouds.http.options.HttpRequestOptions;
@@ -99,6 +100,7 @@ import org.jclouds.rest.annotations.VirtualHost;
 import org.jclouds.rest.annotations.WrapWith;
 import org.jclouds.rest.binders.BindMapToStringPayload;
 import org.jclouds.rest.binders.BindToJsonPayloadWrappedWith;
+import org.jclouds.util.RegionHandler;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Function;
@@ -377,6 +379,31 @@ public class RestAnnotationProcessor implements Function<Invocation, HttpRequest
          if (endpoint.isPresent())
             logger.trace("using default endpoint %s for %s", endpoint, invocation);
       }
+      if ((endpoint != null) && (endpoint.get() != null) && (endpoint.get().getHost() != null)) {
+         URI original = endpoint.get();
+         if (original.getHost().contains("amazonaws.com")) {
+         /* we recognize the csp's type(oss or aws), if original contains 'amazonaws.com' */  
+         String ossPrivateEndpint = "";
+         if (RegionHandler.CSP_REGION.startsWith("https://")) {
+            ossPrivateEndpint = RegionHandler.CSP_REGION.substring(8);
+            original = Uris.uriBuilder(original).host(ossPrivateEndpint).build();
+	   } else {
+             if (RegionHandler.CSP_REGION.startsWith("http://")) {
+                ossPrivateEndpint = RegionHandler.CSP_REGION.substring(7);
+                original = Uris.uriBuilder(original).host(ossPrivateEndpint).build();
+             } else {
+                if (RegionHandler.CSP_REGION.contains("oss-")) {
+                   original = Uris.uriBuilder(original).host(RegionHandler.CSP_REGION + ".aliyuncs.com").build();
+                }else {
+                   if (RegionHandler.CSP_REGION.contains("cn-north-1")) {
+                      original = Uris.uriBuilder(original).host("s3.cn-north-1.amazonaws.com.cn").build();
+                   }
+                 }
+              }
+            }
+        }
+         return Optional.fromNullable(original);
+      }
       return endpoint;
    }
 
diff --git a/core/src/main/java/org/jclouds/util/RegionHandler.java b/core/src/main/java/org/jclouds/util/RegionHandler.java
new file mode 100644
index 0000000000..69461473f7
--- /dev/null
+++ b/core/src/main/java/org/jclouds/util/RegionHandler.java
@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ * Copyright(C) Inspur Corp. 2017,2018
+ * 
+ * COMPONENT NAME: indigo_MCSTORE
+ * FILE NAME: core/src/main/java/org/jclouds/util/RegionHandler.java
+ * DESCRIPTION: add this class for handling the region information
+ * when the csp (cloud service provider) is aliyunoss.
+ * 
+ * Change Log.
+ * 
+ * 14-06-2017 zreal,Inspur File creation.
+ * 
+ */
+package org.jclouds.util;
+
+
+public class RegionHandler {
+
+	/* identify the CSP_REGION during handle the request */
+	public static String CSP_REGION = "";
+	
+	/* zreal the length of the oss accesskeyid */
+	public static final int OSS_ACCESS_KEY_ID_LENGTH = 16;
+	
+	/* zreal the length of the oss secretaccesskey */
+	public static final int OSS_SECRET_ACCESS_KEY_LENGTH = 30;
+	
+}
diff --git a/providers/aws-ec2/src/main/java/org/jclouds/aws/ec2/AWSEC2ProviderMetadata.java b/providers/aws-ec2/src/main/java/org/jclouds/aws/ec2/AWSEC2ProviderMetadata.java
index 8d7054dffe..648b9c94b4 100644
--- a/providers/aws-ec2/src/main/java/org/jclouds/aws/ec2/AWSEC2ProviderMetadata.java
+++ b/providers/aws-ec2/src/main/java/org/jclouds/aws/ec2/AWSEC2ProviderMetadata.java
@@ -86,7 +86,7 @@ public class AWSEC2ProviderMetadata extends BaseProviderMetadata {
          .console(URI.create("https://console.aws.amazon.com/ec2/home"))
          .defaultProperties(AWSEC2ProviderMetadata.defaultProperties())
          .linkedServices("aws-ec2", "aws-elb", "aws-cloudwatch", "aws-s3", "aws-simpledb")
-         .iso3166Codes("US-VA", "US-CA", "US-OR", "BR-SP", "IE", "DE-HE", "SG", "AU-NSW", "JP-13");
+         .iso3166Codes("US-VA", "US-CA", "US-OR", "BR-SP", "IE", "DE-HE", "SG", "AU-NSW", "JP-13", "CN-11");
       }
 
       @Override
diff --git a/providers/aws-s3/src/main/java/org/jclouds/aws/s3/AWSS3ProviderMetadata.java b/providers/aws-s3/src/main/java/org/jclouds/aws/s3/AWSS3ProviderMetadata.java
index 899c3decb1..132d52f77b 100644
--- a/providers/aws-s3/src/main/java/org/jclouds/aws/s3/AWSS3ProviderMetadata.java
+++ b/providers/aws-s3/src/main/java/org/jclouds/aws/s3/AWSS3ProviderMetadata.java
@@ -25,6 +25,21 @@ import static org.jclouds.aws.domain.Region.SA_EAST_1;
 import static org.jclouds.aws.domain.Region.US_STANDARD;
 import static org.jclouds.aws.domain.Region.US_WEST_1;
 import static org.jclouds.aws.domain.Region.US_WEST_2;
+import static org.jclouds.aws.domain.Region.CN_NORTH_1;
+import static org.jclouds.aws.domain.Region.OSS_CN_SHANGHAI;
+import static org.jclouds.aws.domain.Region.OSS_CN_HANGZHOU;
+import static org.jclouds.aws.domain.Region.OSS_CN_QINGDAO;
+import static org.jclouds.aws.domain.Region.OSS_CN_BEIJING;
+import static org.jclouds.aws.domain.Region.OSS_CN_ZHANGJIAKOU;
+import static org.jclouds.aws.domain.Region.OSS_CN_SHENZHEN;
+import static org.jclouds.aws.domain.Region.OSS_CN_HONGKONG;
+import static org.jclouds.aws.domain.Region.OSS_US_WEST_1;
+import static org.jclouds.aws.domain.Region.OSS_US_EAST_1;
+import static org.jclouds.aws.domain.Region.OSS_AP_SOUTHEAST_1;
+import static org.jclouds.aws.domain.Region.OSS_AP_SOUTHEAST_2;
+import static org.jclouds.aws.domain.Region.OSS_AP_NORTHEAST_1;
+import static org.jclouds.aws.domain.Region.OSS_EU_CENTRAL;
+import static org.jclouds.aws.domain.Region.OSS_ME_EAST_1;
 import static org.jclouds.location.reference.LocationConstants.ENDPOINT;
 import static org.jclouds.location.reference.LocationConstants.PROPERTY_REGION;
 
@@ -64,7 +79,7 @@ public class AWSS3ProviderMetadata extends BaseProviderMetadata {
    public static Properties defaultProperties() {
       Properties properties = new Properties();
       properties.putAll(Region.regionPropertiesS3());
-      properties.setProperty(PROPERTY_ENDPOINT, "https://s3.amazonaws.com");
+      properties.setProperty(PROPERTY_ENDPOINT, "https://oss.aliyuncs.com"); // https://s3.amazonaws.com
       properties.setProperty(PROPERTY_REGION + "." + US_STANDARD + "." + ENDPOINT, "https://s3.amazonaws.com");
       properties.setProperty(PROPERTY_REGION + "." + US_WEST_1 + "." + ENDPOINT, "https://s3-us-west-1.amazonaws.com");
       properties.setProperty(PROPERTY_REGION + "." + US_WEST_2 + "." + ENDPOINT, "https://s3-us-west-2.amazonaws.com");
@@ -76,6 +91,36 @@ public class AWSS3ProviderMetadata extends BaseProviderMetadata {
             "https://s3-ap-southeast-2.amazonaws.com");
       properties.setProperty(PROPERTY_REGION + "." + AP_NORTHEAST_1 + "." + ENDPOINT,
             "https://s3-ap-northeast-1.amazonaws.com");
+      properties.setProperty(PROPERTY_REGION + "." + CN_NORTH_1 + "." + ENDPOINT,
+    		"https://s3.cn-north-1.amazonaws.com.cn");
+      properties.setProperty(PROPERTY_REGION + "." + OSS_CN_SHANGHAI + "." + ENDPOINT,
+              "http://oss-cn-shanghai.aliyuncs.com");
+      properties.setProperty(PROPERTY_REGION + "." + OSS_CN_HANGZHOU + "." + ENDPOINT,
+              "http://oss-cn-hangzhou.aliyuncs.com");
+      properties.setProperty(PROPERTY_REGION + "." + OSS_CN_QINGDAO + "." + ENDPOINT,
+              "http://oss-cn-qingdao.aliyuncs.com");
+      properties.setProperty(PROPERTY_REGION + "." + OSS_CN_BEIJING + "." + ENDPOINT,
+              "http://oss-cn-beijing.aliyuncs.com");
+      properties.setProperty(PROPERTY_REGION + "." + OSS_CN_ZHANGJIAKOU + "." + ENDPOINT,
+              "http://oss-cn-zhangjiakou.aliyuncs.com");
+      properties.setProperty(PROPERTY_REGION + "." + OSS_CN_SHENZHEN + "." + ENDPOINT,
+              "http://oss-cn-shenzhen.aliyuncs.com");
+      properties.setProperty(PROPERTY_REGION + "." + OSS_CN_HONGKONG + "." + ENDPOINT,
+              "http://oss-cn-hongkong.aliyuncs.com");
+      properties.setProperty(PROPERTY_REGION + "." + OSS_US_WEST_1 + "." + ENDPOINT,
+              "http://oss-us-west-1.aliyuncs.com");
+      properties.setProperty(PROPERTY_REGION + "." + OSS_US_EAST_1 + "." + ENDPOINT,
+              "http://oss-us-east-1.aliyuncs.com");
+      properties.setProperty(PROPERTY_REGION + "." + OSS_AP_SOUTHEAST_1 + "." + ENDPOINT,
+              "http://oss-ap-southeast-1.aliyuncs.com");
+      properties.setProperty(PROPERTY_REGION + "." + OSS_AP_SOUTHEAST_2 + "." + ENDPOINT,
+              "http://oss-ap-southeast-2.aliyuncs.com");
+      properties.setProperty(PROPERTY_REGION + "." + OSS_AP_NORTHEAST_1 + "." + ENDPOINT,
+              "http://oss-ap-northeast-1.aliyuncs.com");
+      properties.setProperty(PROPERTY_REGION + "." + OSS_EU_CENTRAL + "." + ENDPOINT,
+              "http://oss-eu-central.aliyuncs.com");
+      properties.setProperty(PROPERTY_REGION + "." + OSS_ME_EAST_1 + "." + ENDPOINT,
+              "http://oss-me-east-1.aliyuncs.com");
       return properties;
    }
    
@@ -85,10 +130,10 @@ public class AWSS3ProviderMetadata extends BaseProviderMetadata {
          id("aws-s3")
          .name("Amazon Simple Storage Service (S3)")
          .apiMetadata(new AWSS3ApiMetadata())
-         .homepage(URI.create("http://aws.amazon.com/s3"))
+         .homepage(URI.create("http://oss-cn-shanghai.aliyuncs.com"))
          .console(URI.create("https://console.aws.amazon.com/s3/home"))
          .linkedServices("aws-ec2", "aws-elb", "aws-cloudwatch", "aws-s3", "aws-simpledb")
-         .iso3166Codes("US", "US-CA", "US-OR", "BR-SP", "IE", "SG", "AU-NSW", "JP-13")
+         .iso3166Codes("US", "US-CA", "US-OR", "BR-SP", "IE", "SG", "AU-NSW", "JP-13", "CN-11")
          .defaultProperties(AWSS3ProviderMetadata.defaultProperties());
       }
 
